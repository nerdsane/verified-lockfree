{
  "id": "2d4507a60e2500f6",
  "code": "use std::sync::atomic::{AtomicUsize, AtomicPtr, Ordering};\nuse std::ptr;\nuse std::mem::MaybeUninit;\nuse std::cell::UnsafeCell;\nuse crossbeam_epoch::{self as epoch, Atomic, Owned, Shared, Guard};\n\npub struct RingBuffer<T> {\n    buffer: Box<[UnsafeCell<MaybeUninit<T>>]>,\n    capacity: usize,\n    head: AtomicUsize,\n    tail: AtomicUsize,\n    size: AtomicUsize,\n}\n\nunsafe impl<T: Send> Send for RingBuffer<T> {}\nunsafe impl<T: Send> Sync for RingBuffer<T> {}\n\nimpl<T> RingBuffer<T> {\n    pub fn new(capacity: usize) -> Self {\n        debug_assert!(capacity > 0, \"capacity must be positive\");\n        \n        let mut buffer = Vec::with_capacity(capacity);\n        for _ in 0..capacity {\n            buffer.push(UnsafeCell::new(MaybeUninit::uninit()));\n        }\n        \n        RingBuffer {\n            buffer: buffer.into_boxed_slice(),\n            capacity,\n            head: AtomicUsize::new(0),\n            tail: AtomicUsize::new(0),\n            size: AtomicUsize::new(0),\n        }\n    }\n\n    pub fn push(&self, value: T) -> bool {\n        loop {\n            let current_size = self.size.load(Ordering::Acquire);\n            if current_size >= self.capacity {\n                return false;\n            }\n\n            let tail = self.tail.load(Ordering::Acquire);\n            let new_tail = (tail + 1) % self.capacity;\n\n            if self.tail.compare_exchange_weak(\n                tail,\n                new_tail,\n                Ordering::Release,\n                Ordering::Relaxed\n            ).is_ok() {\n                unsafe {\n                    (*self.buffer[tail].get()).write(value);\n                }\n                \n                loop {\n                    let old_size = self.size.load(Ordering::Acquire);\n                    if self.size.compare_exchange_weak(\n                        old_size,\n                        old_size + 1,\n                        Ordering::Release,\n                        Ordering::Relaxed\n                    ).is_ok() {\n                        break;\n                    }\n                }\n                \n                return true;\n            }\n        }\n    }\n\n    pub fn pop(&self) -> Option<T> {\n        loop {\n            let current_size = self.size.load(Ordering::Acquire);\n            if current_size == 0 {\n                return None;\n            }\n\n            let head = self.head.load(Ordering::Acquire);\n            let new_head = (head + 1) % self.capacity;\n\n            if self.head.compare_exchange_weak(\n                head,\n                new_head,\n                Ordering::Release,\n                Ordering::Relaxed\n            ).is_ok() {\n                let value = unsafe {\n                    (*self.buffer[head].get()).assume_init_read()\n                };\n                \n                loop {\n                    let old_size = self.size.load(Ordering::Acquire);\n                    if self.size.compare_exchange_weak(\n                        old_size,\n                        old_size - 1,\n                        Ordering::Release,\n                        Ordering::Relaxed\n                    ).is_ok() {\n                        break;\n                    }\n                }\n                \n                return Some(value);\n            }\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.size.load(Ordering::Acquire)\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.size.load(Ordering::Acquire) == 0\n    }\n\n    pub fn is_full(&self) -> bool {\n        self.size.load(Ordering::Acquire) >= self.capacity\n    }\n\n    pub fn capacity(&self) -> usize {\n        self.capacity\n    }\n}\n\nimpl<T> Drop for RingBuffer<T> {\n    fn drop(&mut self) {\n        while self.pop().is_some() {}\n    }\n}",
  "score": 160.0,
  "correct": false,
  "generation": 1,
  "parent_id": "7048eb073533c90e",
  "island": 0,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (21.3s)\n- miri: FAIL (60.7s) â€” error: \"error: Undefined Behavior: Data race detected between (1) non-atomic read on thread `unnamed-7` and (2) retag write of type `std::mem::MaybeUninit<usize>` on thread `unnamed-4` at alloc48524+0xf8\"\n  output: \"\\nrunning 7 tests\\ntest tests::tests::test_bounded_capacity ... ok\\ntest tests::tests::test_concurrent_multi_producer ... \\n    Blocking waiting for file lock on package cache\\n    Blocking waiting for file lock on package cache\\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling rustix v1.1.3\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling shlex v1.3.0\\n   Compiling regex-syntax v0.8.9\\n   Compiling zerocopy v0.8.39\\n   Compiling bitflags v2.10.0\\n   Compiling cc v1.2.55\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling tracing-core v0.1.36\\n   Compiling autocfg v1.5.0\\n   Compiling log v0.4.29\\n   Compiling lazy_static v1.5.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling fastrand v2.3.0\\n   Compiling sharded-slab v0.1.7\\n   Compiling num-traits v0.2.19\\n   Compiling thread_local v1.1.9\\n   Compiling tracing v0.1.44\\n   Compiling tracing-log v0.2.0\\n   Compiling fnv v1.0.7\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling smallvec v1.15.1\\n   Compiling bit-vec v0.8.0\\n   Compiling quick-error v1.2.3\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling unarray v0.1.4\\n   Compiling scoped-tls v1.0.1\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling bit-set v0.8.0\\n   Compiling rand_core v0.9.5\\n   Compiling rand_xorshift v0.4.0\\n   Compiling rand v0.9.2\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-6726941513235414309)\\nwarning: unused import: `AtomicPtr`\\n --> src/lib.rs:1:38\\n  |\\n1 | use std::sync::atomic::{AtomicUsize, AtomicPtr, Ordering};\\n  |                                      ^^^^^^^^^\\n  |\\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\\n\\nwarning: unused import: `std::ptr`\\n --> src/lib.rs:2:5\\n  |\\n2 | use std::ptr;\\n  |     ^^^^^^^^\\n\\nwarning: unused imports: `Atomic`, `Guard`, `Owned`, `Shared`, and `self as epoch`\\n --> src/lib.rs:5:23\\n  |\\n5 | use crossbeam_epoch::{self as \"\n",
  "model": "opus"
}