{
  "id": "a0249036c9d19ebb",
  "code": "/// Transaction Scheduling - Lock-Free Optimization\n/// Implements an obstructionless scheduler with CAS-based resource tracking\n/// and priority-aware assignment heuristics.\n\nuse std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};\nuse std::sync::Arc;\n\n/// A transaction with resource requirements and timing.\n#[derive(Debug, Clone)]\npub struct Transaction {\n    pub id: u64,\n    pub duration: f64,\n    pub resource_requirement: u64,\n    pub priority: u64,\n    pub arrival_time: f64,\n    pub deadline: Option<f64>,\n}\n\n/// Result of scheduling a single transaction.\n#[derive(Debug, Clone)]\npub struct ScheduleEntry {\n    pub txn_id: u64,\n    pub resource_id: u64,\n    pub start_time: f64,\n}\n\n/// Result of scheduling a batch of transactions.\n#[derive(Debug, Clone)]\npub struct ScheduleResult {\n    pub assignments: Vec<ScheduleEntry>,\n    pub makespan: f64,\n    pub missed_deadlines: u64,\n    pub utilization: f64,\n}\n\n/// Atomic representation of resource state (bits: available_at_time_bits | resource_id)\n#[derive(Debug)]\nstruct ResourceState {\n    available_at_bits: AtomicU64,\n}\n\nimpl ResourceState {\n    fn new() -> Self {\n        ResourceState {\n            available_at_bits: AtomicU64::new(0),\n        }\n    }\n\n    fn get_available_at(&self) -> f64 {\n        let bits = self.available_at_bits.load(Ordering::Acquire);\n        f64::from_bits(bits)\n    }\n\n    fn set_available_at(&self, time: f64) {\n        let bits = time.to_bits();\n        self.available_at_bits.store(bits, Ordering::Release);\n    }\n\n    fn try_reserve(&self, arrival_time: f64, duration: f64) -> Option<f64> {\n        loop {\n            let current_bits = self.available_at_bits.load(Ordering::Acquire);\n            let current_time = f64::from_bits(current_bits);\n            let start_time = current_time.max(arrival_time);\n            let finish_time = start_time + duration;\n            let finish_bits = finish_time.to_bits();\n\n            match self.available_at_bits.compare_exchange(\n                current_bits,\n                finish_bits,\n                Ordering::Release,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => return Some(start_time),\n                Err(_) => continue,\n            }\n        }\n    }\n}\n\n/// Schedule transactions across `num_resources` identical resources with priority awareness.\n///\n/// Returns assignments minimizing makespan and deadline misses.\n/// Uses lock-free CAS operations for resource state management.\npub fn schedule(transactions: &[Transaction], num_resources: u64) -> ScheduleResult {\n    debug_assert!(num_resources > 0, \"Must have at least one resource\");\n    debug_assert!(!transactions.is_empty(), \"Must have at least one transaction\");\n\n    let num_res = num_resources as usize;\n    \n    // Initialize resource states (lock-free atomic structures)\n    let resources: Vec<Arc<ResourceState>> = (0..num_res)\n        .map(|_| Arc::new(ResourceState::new()))\n        .collect();\n\n    let mut assignments = Vec::with_capacity(transactions.len());\n    let mut missed_deadlines: u64 = 0;\n    let mut total_busy_time: f64 = 0.0;\n\n    // Sort by priority (descending), then by arrival time (ascending)\n    let mut sorted: Vec<&Transaction> = transactions.iter().collect();\n    sorted.sort_by(|a, b| {\n        match b.priority.cmp(&a.priority) {\n            std::cmp::Ordering::Equal => a.arrival_time.partial_cmp(&b.arrival_time).unwrap(),\n            other => other,\n        }\n    });\n\n    for txn in &sorted {\n        // Find best resource using lock-free reads\n        let mut best_resource_idx = 0;\n        let mut best_available_time = f64::INFINITY;\n\n        for (idx, resource) in resources.iter().enumerate() {\n            let available_at = resource.get_available_at();\n            if available_at < best_available_time {\n                best_available_time = available_at;\n                best_resource_idx = idx;\n            }\n        }\n\n        // Try to reserve the best resource (may need retries due to CAS)\n        let resource = &resources[best_resource_idx];\n        let start_time = resource\n            .try_reserve(txn.arrival_time, txn.duration)\n            .unwrap();\n        \n        let finish_time = start_time + txn.duration;\n        total_busy_time += txn.duration;\n\n        assignments.push(ScheduleEntry {\n            txn_id: txn.id,\n            resource_id: best_resource_idx as u64,\n            start_time,\n        });\n\n        if let Some(deadline) = txn.deadline {\n            if finish_time > deadline {\n                missed_deadlines += 1;\n            }\n        }\n    }\n\n    // Calculate makespan by reading all resource states\n    let mut makespan = 0.0f64;\n    for resource in &resources {\n        let available_at = resource.get_available_at();\n        if available_at > makespan {\n            makespan = available_at;\n        }\n    }\n\n    let total_capacity_time = if makespan > 0.0 {\n        makespan * num_resources as f64\n    } else {\n        1.0\n    };\n    let utilization = (total_busy_time / total_capacity_time).min(1.0);\n\n    ScheduleResult {\n        assignments,\n        makespan,\n        missed_deadlines,\n        utilization,\n    }\n}",
  "score": 270.0,
  "correct": true,
  "generation": 6,
  "parent_id": "a1ac67eeb61059b1",
  "island": 0,
  "level_reached": 1,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (46.6s)\n- miri: PASS (50.7s)\n",
  "model": "haiku"
}