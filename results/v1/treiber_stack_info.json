{
  "id": "55b559eaa5d58a9a",
  "code": "use std::sync::atomic::{AtomicPtr, Ordering};\nuse crossbeam_epoch::{self as epoch, Atomic, Guard, Owned, Shared};\nuse std::ptr;\n\nstruct Node<T> {\n    data: T,\n    next: Atomic<Node<T>>,\n}\n\npub struct TreiberStack<T> {\n    head: Atomic<Node<T>>,\n}\n\nimpl<T> TreiberStack<T> {\n    pub fn new() -> Self {\n        TreiberStack {\n            head: Atomic::null(),\n        }\n    }\n\n    pub fn push(&self, value: T) {\n        let guard = &epoch::pin();\n        let mut new_node = Owned::new(Node {\n            data: value,\n            next: Atomic::null(),\n        });\n\n        loop {\n            let head = self.head.load(Ordering::Acquire, guard);\n            new_node.next.store(head, Ordering::Relaxed);\n            \n            match self.head.compare_exchange(\n                head,\n                new_node,\n                Ordering::Release,\n                Ordering::Acquire,\n                guard,\n            ) {\n                Ok(_) => break,\n                Err(e) => new_node = e.new,\n            }\n        }\n    }\n\n    pub fn pop(&self) -> Option<T> {\n        let guard = &epoch::pin();\n        loop {\n            let head = self.head.load(Ordering::Acquire, guard);\n            match unsafe { head.as_ref() } {\n                None => return None,\n                Some(node) => {\n                    let next = node.next.load(Ordering::Acquire, guard);\n                    match self.head.compare_exchange(\n                        head,\n                        next,\n                        Ordering::Release,\n                        Ordering::Acquire,\n                        guard,\n                    ) {\n                        Ok(_) => {\n                            let data = unsafe { ptr::read(&node.data) };\n                            unsafe {\n                                guard.defer_destroy(head);\n                            }\n                            return Some(data);\n                        }\n                        Err(_) => continue,\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        let guard = &epoch::pin();\n        self.head.load(Ordering::Acquire, guard).is_null()\n    }\n\n    pub fn len(&self) -> usize {\n        let guard = &epoch::pin();\n        let mut count = 0;\n        let mut current = self.head.load(Ordering::Acquire, guard);\n        \n        while let Some(node) = unsafe { current.as_ref() } {\n            count += 1;\n            current = node.next.load(Ordering::Acquire, guard);\n        }\n        \n        count\n    }\n}\n\nunsafe impl<T: Send> Send for TreiberStack<T> {}\nunsafe impl<T: Send> Sync for TreiberStack<T> {}",
  "score": 160.0,
  "correct": false,
  "generation": 1,
  "parent_id": "b2fe571e47b6562e",
  "island": 0,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (20.0s)\n- miri: FAIL (50.5s) â€” error: \"error: Undefined Behavior: trying to retag from <146042> for SharedReadWrite permission at alloc44265[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 7 tests\\ntest tests::tests::test_concurrent_mixed_push_pop ... \\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling shlex v1.3.0\\n   Compiling regex-syntax v0.8.9\\n   Compiling zerocopy v0.8.39\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling rustix v1.1.3\\n   Compiling bitflags v2.10.0\\n   Compiling cc v1.2.55\\n   Compiling autocfg v1.5.0\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling tracing-core v0.1.36\\n   Compiling log v0.4.29\\n   Compiling lazy_static v1.5.0\\n   Compiling fastrand v2.3.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling sharded-slab v0.1.7\\n   Compiling num-traits v0.2.19\\n   Compiling thread_local v1.1.9\\n   Compiling tracing-log v0.2.0\\n   Compiling tracing v0.1.44\\n   Compiling fnv v1.0.7\\n   Compiling quick-error v1.2.3\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling smallvec v1.15.1\\n   Compiling bit-vec v0.8.0\\n   Compiling scoped-tls v1.0.1\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling unarray v0.1.4\\n   Compiling bit-set v0.8.0\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-11936217530084881425)\\nwarning: unused import: `AtomicPtr`\\n --> src/lib.rs:1:25\\n  |\\n1 | use std::sync::atomic::{AtomicPtr, Ordering};\\n  |                         ^^^^^^^^^\\n  |\\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\\n\\nwarning: unused imports: `Guard` and `Shared`\\n --> src/lib.rs:2:46\\n  |\\n2 | use crossbeam_epoch::{self as epoch, Atomic, Guard, Owned, Shared};\\n  |                                              ^^^^^         ^^^^^^\\n\\nwarning: `vf-temp-crate` (lib) generated 2 warnings (run `cargo fix --lib -p vf-temp-crate` to apply 2 suggestions)\\n   Compiling rand_core v0.9.5\\n   Compiling rand v0.9.2\\n   Compiling rand_xorshift v0.4.0\\n   Compiling generator v0.8.8\\n   Compiling tempfile v3.24.0\\n   Compiling regex-autom\"\n",
  "model": "opus"
}