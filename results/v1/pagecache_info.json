{
  "id": "2d5968d2a3fd0fb7",
  "code": "use std::collections::HashMap;\nuse std::sync::atomic::Ordering;\nuse crossbeam_epoch::{self as epoch, Atomic, Owned};\n\npub struct PageCache {\n    pages: Atomic<HashMap<u64, Vec<u8>>>,\n    dirty: Atomic<HashMap<u64, bool>>,\n    page_size: usize,\n}\n\nimpl PageCache {\n    pub fn new(page_size: usize) -> Self {\n        Self {\n            pages: Atomic::new(HashMap::new()),\n            dirty: Atomic::new(HashMap::new()),\n            page_size,\n        }\n    }\n\n    pub fn read(&self, page_id: u64) -> Option<Vec<u8>> {\n        let guard = &epoch::pin();\n        let pages_ptr = self.pages.load(Ordering::Acquire, guard);\n        if pages_ptr.is_null() {\n            return None;\n        }\n        unsafe {\n            pages_ptr.as_ref().and_then(|pages| pages.get(&page_id).cloned())\n        }\n    }\n\n    pub fn write(&self, page_id: u64, data: Vec<u8>) {\n        loop {\n            let guard = &epoch::pin();\n            let pages_ptr = self.pages.load(Ordering::Acquire, guard);\n            let dirty_ptr = self.dirty.load(Ordering::Acquire, guard);\n            \n            let mut new_pages = if pages_ptr.is_null() {\n                HashMap::new()\n            } else {\n                unsafe { pages_ptr.as_ref().unwrap().clone() }\n            };\n            \n            let mut new_dirty = if dirty_ptr.is_null() {\n                HashMap::new()\n            } else {\n                unsafe { dirty_ptr.as_ref().unwrap().clone() }\n            };\n            \n            new_pages.insert(page_id, data.clone());\n            new_dirty.insert(page_id, true);\n            \n            let new_pages_owned = Owned::new(new_pages);\n            \n            match self.pages.compare_exchange_weak(\n                pages_ptr,\n                new_pages_owned,\n                Ordering::Release,\n                Ordering::Relaxed,\n                guard,\n            ) {\n                Ok(old_pages) => {\n                    let new_dirty_owned = Owned::new(new_dirty);\n                    match self.dirty.compare_exchange_weak(\n                        dirty_ptr,\n                        new_dirty_owned,\n                        Ordering::Release,\n                        Ordering::Relaxed,\n                        guard,\n                    ) {\n                        Ok(old_dirty) => {\n                            if !old_pages.is_null() {\n                                unsafe { guard.defer_destroy(old_pages) };\n                            }\n                            if !old_dirty.is_null() {\n                                unsafe { guard.defer_destroy(old_dirty) };\n                            }\n                            break;\n                        }\n                        Err(_) => continue,\n                    }\n                }\n                Err(_) => continue,\n            }\n        }\n    }\n\n    pub fn flush(&self) {\n        loop {\n            let guard = &epoch::pin();\n            let dirty_ptr = self.dirty.load(Ordering::Acquire, guard);\n            \n            let new_dirty = HashMap::new();\n            let new_dirty_owned = Owned::new(new_dirty);\n            \n            match self.dirty.compare_exchange_weak(\n                dirty_ptr,\n                new_dirty_owned,\n                Ordering::Release,\n                Ordering::Relaxed,\n                guard,\n            ) {\n                Ok(old_dirty) => {\n                    if !old_dirty.is_null() {\n                        unsafe { guard.defer_destroy(old_dirty) };\n                    }\n                    break;\n                }\n                Err(_) => continue,\n            }\n        }\n    }\n\n    pub fn dirty_pages(&self) -> usize {\n        let guard = &epoch::pin();\n        let dirty_ptr = self.dirty.load(Ordering::Acquire, guard);\n        if dirty_ptr.is_null() {\n            0\n        } else {\n            unsafe { dirty_ptr.as_ref().unwrap().len() }\n        }\n    }\n}\n\nimpl Drop for PageCache {\n    fn drop(&mut self) {\n        let guard = &epoch::pin();\n        let pages_ptr = self.pages.load(Ordering::Acquire, guard);\n        let dirty_ptr = self.dirty.load(Ordering::Acquire, guard);\n        \n        if !pages_ptr.is_null() {\n            unsafe { guard.defer_destroy(pages_ptr) };\n        }\n        if !dirty_ptr.is_null() {\n            unsafe { guard.defer_destroy(dirty_ptr) };\n        }\n    }\n}",
  "score": 160.0,
  "correct": false,
  "generation": 4,
  "parent_id": "22198d61ec072049",
  "island": 1,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (44.2s)\n- miri: FAIL (48.4s) â€” error: \"error: Undefined Behavior: trying to retag from <146746> for SharedReadWrite permission at alloc44542[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 8 tests\\ntest tests::tests::test_concurrent_flush ... \\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling rustix v1.1.3\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling regex-syntax v0.8.9\\n   Compiling shlex v1.3.0\\n   Compiling zerocopy v0.8.39\\n   Compiling bitflags v2.10.0\\n   Compiling cc v1.2.55\\n   Compiling log v0.4.29\\n   Compiling autocfg v1.5.0\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling tracing-core v0.1.36\\n   Compiling pin-project-lite v0.2.16\\n   Compiling lazy_static v1.5.0\\n   Compiling fastrand v2.3.0\\n   Compiling sharded-slab v0.1.7\\n   Compiling thread_local v1.1.9\\n   Compiling tracing-log v0.2.0\\n   Compiling tracing v0.1.44\\n   Compiling num-traits v0.2.19\\n   Compiling quick-error v1.2.3\\n   Compiling smallvec v1.15.1\\n   Compiling fnv v1.0.7\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling bit-vec v0.8.0\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling unarray v0.1.4\\n   Compiling scoped-tls v1.0.1\\n   Compiling bit-set v0.8.0\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-5426835452638298048)\\nwarning: field `page_size` is never read\\n --> src/lib.rs:8:5\\n  |\\n5 | pub struct PageCache {\\n  |            --------- field in this struct\\n...\\n8 |     page_size: usize,\\n  |     ^^^^^^^^^\\n  |\\n  = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\\n\\n   Compiling rand_core v0.9.5\\nwarning: `vf-temp-crate` (lib) generated 1 warning\\n   Compiling rand v0.9.2\\n   Compiling rand_xorshift v0.4.0\\n   Compiling generator v0.8.8\\n   Compiling tempfile v3.24.0\\n   Compiling regex-automata v0.4.14\\n   Compiling rusty-fork v0.3.1\\n   Compiling ppv-lite86 v0.2.21\\n   Compiling rand_chacha v0.9.0\\n   Compiling proptest v1.10.0\\n   Compiling matchers v0.2.0\\n   Compiling tracing-subscriber v0.3.22\\n   Compiling loom v0.7.2\\n    Finished `test` profil\"\n",
  "model": "sonnet"
}