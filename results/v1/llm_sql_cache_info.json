{
  "id": "eaf74b8652d029d8",
  "code": "/// LLM SQL Cache - Lock-Free Implementation with Atomic Operations\n/// Uses atomic operations and crossbeam-epoch for safe memory reclamation\n\nuse std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};\nuse crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\n\n/// Cache performance statistics.\n#[derive(Debug, Clone, Default)]\npub struct CacheStats {\n    pub hits: u64,\n    pub misses: u64,\n    pub prefix_hits: u64,\n    pub evictions: u64,\n    pub size: u64,\n}\n\nimpl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        let total = self.hits + self.misses;\n        if total > 0 {\n            self.hits as f64 / total as f64\n        } else {\n            0.0\n        }\n    }\n}\n\n/// A cached SQL query result.\n#[derive(Debug)]\nstruct CacheEntry {\n    query: String,\n    normalized: String,\n    result_id: u64,\n    hit_count: AtomicU64,\n    hash: u64,\n}\n\nimpl Clone for CacheEntry {\n    fn clone(&self) -> Self {\n        Self {\n            query: self.query.clone(),\n            normalized: self.normalized.clone(),\n            result_id: self.result_id,\n            hit_count: AtomicU64::new(self.hit_count.load(Ordering::Relaxed)),\n            hash: self.hash,\n        }\n    }\n}\n\nstruct Node {\n    entry: CacheEntry,\n    next: Atomic<Node>,\n}\n\n/// Lock-free LRU cache for SQL queries with prefix-based approximate matching.\npub struct LockFreeSqlCache {\n    capacity: u64,\n    head: Atomic<Node>,\n    tail: Atomic<Node>,\n    size: AtomicUsize,\n    stats_hits: AtomicU64,\n    stats_misses: AtomicU64,\n    stats_prefix_hits: AtomicU64,\n    stats_evictions: AtomicU64,\n}\n\nimpl LockFreeSqlCache {\n    fn new(capacity: u64) -> Self {\n        Self {\n            capacity,\n            head: Atomic::null(),\n            tail: Atomic::null(),\n            size: AtomicUsize::new(0),\n            stats_hits: AtomicU64::new(0),\n            stats_misses: AtomicU64::new(0),\n            stats_prefix_hits: AtomicU64::new(0),\n            stats_evictions: AtomicU64::new(0),\n        }\n    }\n\n    fn find_entry<'g>(&self, hash: u64, guard: &'g epoch::Guard) -> Option<Shared<'g, Node>> {\n        let mut current = self.head.load(Ordering::Acquire, guard);\n        \n        while !current.is_null() {\n            let node = unsafe { current.deref() };\n            if node.entry.hash == hash {\n                return Some(current);\n            }\n            current = node.next.load(Ordering::Acquire, guard);\n        }\n        None\n    }\n\n    fn insert_entry(&self, entry: CacheEntry, guard: &epoch::Guard) {\n        let new_node = Owned::new(Node {\n            entry,\n            next: Atomic::null(),\n        });\n\n        let new_shared = new_node.into_shared(guard);\n\n        // Insert at head\n        loop {\n            let head = self.head.load(Ordering::Acquire, guard);\n            unsafe { new_shared.deref() }.next.store(head, Ordering::Relaxed);\n            \n            match self.head.compare_exchange_weak(\n                head,\n                new_shared,\n                Ordering::Release,\n                Ordering::Relaxed,\n                guard,\n            ) {\n                Ok(_) => break,\n                Err(_) => continue,\n            }\n        }\n\n        // Update tail if this is the first node\n        if self.tail.load(Ordering::Acquire, guard).is_null() {\n            let _ = self.tail.compare_exchange(\n                Shared::null(),\n                new_shared,\n                Ordering::Release,\n                Ordering::Relaxed,\n                guard,\n            );\n        }\n\n        let old_size = self.size.fetch_add(1, Ordering::AcqRel);\n        \n        // Evict if necessary\n        if old_size + 1 > self.capacity as usize {\n            self.evict_lru(guard);\n        }\n    }\n\n    fn evict_lru(&self, guard: &epoch::Guard) {\n        let tail = self.tail.load(Ordering::Acquire, guard);\n        if tail.is_null() {\n            return;\n        }\n\n        // Find the node before tail\n        let mut current = self.head.load(Ordering::Acquire, guard);\n        let mut prev = Shared::null();\n\n        while !current.is_null() {\n            let node = unsafe { current.deref() };\n            let next = node.next.load(Ordering::Acquire, guard);\n            \n            if next == tail {\n                prev = current;\n                break;\n            }\n            current = next;\n        }\n\n        if !prev.is_null() {\n            // Update the previous node to point to null\n            let prev_node = unsafe { prev.deref() };\n            prev_node.next.store(Shared::null(), Ordering::Release);\n            \n            // Update tail\n            let _ = self.tail.compare_exchange(\n                tail,\n                prev,\n                Ordering::Release,\n                Ordering::Relaxed,\n                guard,\n            );\n\n            self.size.fetch_sub(1, Ordering::AcqRel);\n            self.stats_evictions.fetch_add(1, Ordering::Relaxed);\n            \n            unsafe {\n                guard.defer_destroy(tail);\n            }\n        }\n    }\n\n    fn get_stats(&self) -> CacheStats {\n        CacheStats {\n            hits: self.stats_hits.load(Ordering::Relaxed),\n            misses: self.stats_misses.load(Ordering::Relaxed),\n            prefix_hits: self.stats_prefix_hits.load(Ordering::Relaxed),\n            evictions: self.stats_evictions.load(Ordering::Relaxed),\n            size: self.size.load(Ordering::Relaxed) as u64,\n        }\n    }\n\n    fn lookup(&self, normalized: &str) -> bool {\n        let hash = simple_hash(normalized);\n        let guard = &epoch::pin();\n        \n        if let Some(node_ref) = self.find_entry(hash, guard) {\n            let node = unsafe { node_ref.deref() };\n            node.entry.hit_count.fetch_add(1, Ordering::Relaxed);\n            self.stats_hits.fetch_add(1, Ordering::Relaxed);\n            return true;\n        }\n\n        // Check prefix match\n        let prefix = extract_prefix(normalized, 3);\n        let prefix_hash = simple_hash(&prefix);\n        \n        let mut current = self.head.load(Ordering::Acquire, guard);\n        while !current.is_null() {\n            let node = unsafe { current.deref() };\n            let entry_prefix = extract_prefix(&node.entry.normalized, 3);\n            if simple_hash(&entry_prefix) == prefix_hash {\n                self.stats_prefix_hits.fetch_add(1, Ordering::Relaxed);\n                self.stats_hits.fetch_add(1, Ordering::Relaxed);\n                return true;\n            }\n            current = node.next.load(Ordering::Acquire, guard);\n        }\n\n        self.stats_misses.fetch_add(1, Ordering::Relaxed);\n        false\n    }\n\n    fn insert(&self, query: &str, result_id: u64) {\n        let normalized = normalize_query(query);\n        let hash = simple_hash(&normalized);\n        \n        let entry = CacheEntry {\n            query: query.to_string(),\n            normalized,\n            result_id,\n            hit_count: AtomicU64::new(0),\n            hash,\n        };\n\n        let guard = &epoch::pin();\n        self.insert_entry(entry, guard);\n    }\n}\n\n/// Normalize a SQL query for cache key generation.\npub fn normalize_query(query: &str) -> String {\n    let mut q = query.trim().to_lowercase();\n    // Collapse whitespace\n    let mut prev_space = false;\n    q = q\n        .chars()\n        .filter(|&c| {\n            if c.is_whitespace() {\n                if prev_space {\n                    return false;\n                }\n                prev_space = true;\n            } else {\n                prev_space = false;\n            }\n            true\n        })\n        .collect();\n    // Remove trailing semicolons\n    while q.ends_with(';') {\n        q.pop();\n    }\n    q\n}\n\nfn extract_prefix(normalized: &str, depth: usize) -> String {\n    normalized\n        .split_whitespace()\n        .take(depth)\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\nfn simple_hash(s: &str) -> u64 {\n    let mut h: u64 = 0xcbf29ce484222325;\n    for b in s.bytes() {\n        h ^= b as u64;\n        h = h.wrapping_mul(0x100000001b3);\n    }\n    h\n}\n\n/// Run the cache strategy on a stream of queries.\n///\n/// Returns CacheStats summarizing hit rate performance.\n/// Higher hit_rate indicates a better caching strategy.\npub fn cache_strategy(queries: &[&str], capacity: u64) -> CacheStats {\n    debug_assert!(capacity > 0, \"Cache capacity must be positive\");\n\n    let cache = LockFreeSqlCache::new(capacity);\n\n    for (i, query) in queries.iter().enumerate() {\n        let normalized = normalize_query(query);\n        \n        if !cache.lookup(&normalized) {\n            cache.insert(query, i as u64);\n        }\n    }\n\n    cache.get_stats()\n}",
  "score": 160.0,
  "correct": false,
  "generation": 4,
  "parent_id": "6b87d4420e1ebafc",
  "island": 1,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (35.2s)\n- miri: FAIL (58.3s) â€” error: \"error: Undefined Behavior: trying to retag from <145357> for SharedReadWrite permission at alloc44365[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 7 tests\\ntest tests::tests::test_capacity_causes_evictions ... \\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling rustix v1.1.3\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling regex-syntax v0.8.9\\n   Compiling zerocopy v0.8.39\\n   Compiling shlex v1.3.0\\n   Compiling tracing-core v0.1.36\\n   Compiling cc v1.2.55\\n   Compiling log v0.4.29\\n   Compiling bitflags v2.10.0\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling autocfg v1.5.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling lazy_static v1.5.0\\n   Compiling fastrand v2.3.0\\n   Compiling sharded-slab v0.1.7\\n   Compiling tracing v0.1.44\\n   Compiling tracing-log v0.2.0\\n   Compiling thread_local v1.1.9\\n   Compiling quick-error v1.2.3\\n   Compiling num-traits v0.2.19\\n   Compiling bit-vec v0.8.0\\n   Compiling smallvec v1.15.1\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling rand_core v0.9.5\\n   Compiling fnv v1.0.7\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling bit-set v0.8.0\\n   Compiling rand v0.9.2\\n   Compiling rand_xorshift v0.4.0\\n   Compiling unarray v0.1.4\\n   Compiling scoped-tls v1.0.1\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-4153897303998452110)\\n   Compiling generator v0.8.8\\n   Compiling tempfile v3.24.0\\n   Compiling regex-automata v0.4.14\\n   Compiling rusty-fork v0.3.1\\n   Compiling ppv-lite86 v0.2.21\\n   Compiling matchers v0.2.0\\n   Compiling tracing-subscriber v0.3.22\\n   Compiling rand_chacha v0.9.0\\n   Compiling proptest v1.10.0\\n   Compiling loom v0.7.2\\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 49.45s\\n     Running unittests src/lib.rs (target/miri/aarch64-apple-darwin/debug/deps/vf_temp_crate-3d71d4f29c481fe3)\\nwarning: integer-to-pointer cast\\n   --> /Users/sesh.nalla/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-epoch-0.9.18/src/atomic.rs\"\n",
  "model": "sonnet"
}