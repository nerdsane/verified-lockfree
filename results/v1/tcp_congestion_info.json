{
  "id": "69d8bb6b46f0c362",
  "code": "/// TCP Congestion Control - Lock-Free Implementation with Advanced AIMD\n/// Uses atomic operations for thread-safe congestion control with BBR-inspired enhancements.\n\nuse std::sync::atomic::{AtomicU64, AtomicBool, Ordering};\nuse crossbeam_epoch::{self as epoch, Atomic, Owned};\n\n/// A network event (ACK or loss).\n#[derive(Debug, Clone)]\npub enum NetworkEvent {\n    Ack {\n        timestamp: f64,\n        bytes: u64,\n        rtt: f64,\n    },\n    Loss {\n        timestamp: f64,\n    },\n}\n\nimpl NetworkEvent {\n    pub fn timestamp(&self) -> f64 {\n        match self {\n            NetworkEvent::Ack { timestamp, .. } => *timestamp,\n            NetworkEvent::Loss { timestamp } => *timestamp,\n        }\n    }\n}\n\n/// State of the congestion controller.\n#[derive(Debug, Clone)]\npub struct CongestionState {\n    pub cwnd: f64,\n    pub ssthresh: f64,\n    pub rtt_estimate: f64,\n    pub in_slow_start: bool,\n    pub bytes_acked: u64,\n    pub losses: u64,\n}\n\n/// Result of running a congestion simulation.\n#[derive(Debug, Clone)]\npub struct SimulationResult {\n    pub throughput: f64,\n    pub total_losses: u64,\n    pub avg_cwnd: f64,\n    pub goodput_ratio: f64,\n}\n\nconst CWND_MIN: f64 = 1.0;\nconst CWND_MAX: f64 = 1024.0;\n\n#[repr(C)]\nstruct AtomicState {\n    cwnd_bits: AtomicU64,\n    ssthresh_bits: AtomicU64,\n    rtt_estimate_bits: AtomicU64,\n    in_slow_start: AtomicBool,\n    bytes_acked: AtomicU64,\n    losses: AtomicU64,\n    bandwidth_sum_bits: AtomicU64,\n    bandwidth_count: AtomicU64,\n}\n\nimpl AtomicState {\n    fn new() -> Self {\n        Self {\n            cwnd_bits: AtomicU64::new(1.0f64.to_bits()),\n            ssthresh_bits: AtomicU64::new(64.0f64.to_bits()),\n            rtt_estimate_bits: AtomicU64::new(0.1f64.to_bits()),\n            in_slow_start: AtomicBool::new(true),\n            bytes_acked: AtomicU64::new(0),\n            losses: AtomicU64::new(0),\n            bandwidth_sum_bits: AtomicU64::new(0.0f64.to_bits()),\n            bandwidth_count: AtomicU64::new(0),\n        }\n    }\n\n    fn load_cwnd(&self) -> f64 {\n        f64::from_bits(self.cwnd_bits.load(Ordering::Acquire))\n    }\n\n    fn store_cwnd(&self, value: f64) {\n        self.cwnd_bits.store(value.to_bits(), Ordering::Release);\n    }\n\n    fn load_ssthresh(&self) -> f64 {\n        f64::from_bits(self.ssthresh_bits.load(Ordering::Acquire))\n    }\n\n    fn store_ssthresh(&self, value: f64) {\n        self.ssthresh_bits.store(value.to_bits(), Ordering::Release);\n    }\n\n    fn load_rtt_estimate(&self) -> f64 {\n        f64::from_bits(self.rtt_estimate_bits.load(Ordering::Acquire))\n    }\n\n    fn store_rtt_estimate(&self, value: f64) {\n        self.rtt_estimate_bits.store(value.to_bits(), Ordering::Release);\n    }\n\n    fn cas_cwnd(&self, current: f64, new: f64) -> Result<f64, f64> {\n        match self.cwnd_bits.compare_exchange_weak(\n            current.to_bits(),\n            new.to_bits(),\n            Ordering::AcqRel,\n            Ordering::Acquire\n        ) {\n            Ok(_) => Ok(new),\n            Err(actual_bits) => Err(f64::from_bits(actual_bits)),\n        }\n    }\n\n    fn update_bandwidth(&self, bandwidth: f64) {\n        // Lock-free bandwidth tracking\n        loop {\n            let current_sum_bits = self.bandwidth_sum_bits.load(Ordering::Acquire);\n            let current_sum = f64::from_bits(current_sum_bits);\n            let new_sum = current_sum + bandwidth;\n            \n            match self.bandwidth_sum_bits.compare_exchange_weak(\n                current_sum_bits,\n                new_sum.to_bits(),\n                Ordering::AcqRel,\n                Ordering::Acquire\n            ) {\n                Ok(_) => {\n                    self.bandwidth_count.fetch_add(1, Ordering::Relaxed);\n                    break;\n                }\n                Err(_) => continue,\n            }\n        }\n    }\n\n    fn get_avg_bandwidth(&self) -> f64 {\n        let count = self.bandwidth_count.load(Ordering::Acquire);\n        if count == 0 {\n            return 0.0;\n        }\n        let sum = f64::from_bits(self.bandwidth_sum_bits.load(Ordering::Acquire));\n        sum / count as f64\n    }\n}\n\n/// Run enhanced AIMD congestion control with lock-free atomic operations.\npub fn congestion_control(events: &[NetworkEvent]) -> SimulationResult {\n    debug_assert!(!events.is_empty(), \"Must have at least one event\");\n\n    let state = AtomicState::new();\n    let cwnd_sum = AtomicU64::new(0);\n    let count = AtomicU64::new(0);\n    \n    for event in events {\n        match event {\n            NetworkEvent::Ack { bytes, rtt, timestamp: _ } => {\n                state.bytes_acked.fetch_add(*bytes, Ordering::Relaxed);\n\n                // Update RTT estimate\n                if *rtt > 0.0 {\n                    let current_rtt = state.load_rtt_estimate();\n                    let alpha = 0.125;\n                    let new_rtt = (1.0 - alpha) * current_rtt + alpha * rtt;\n                    state.store_rtt_estimate(new_rtt);\n\n                    // Track bandwidth samples\n                    let bandwidth = *bytes as f64 / rtt;\n                    state.update_bandwidth(bandwidth);\n                }\n\n                // Lock-free congestion window update\n                loop {\n                    let current_cwnd = state.load_cwnd();\n                    let is_slow_start = state.in_slow_start.load(Ordering::Acquire);\n                    let ssthresh = state.load_ssthresh();\n\n                    let new_cwnd = if is_slow_start {\n                        let increased = current_cwnd + 1.0;\n                        if increased >= ssthresh {\n                            state.in_slow_start.store(false, Ordering::Release);\n                        }\n                        increased\n                    } else {\n                        // Enhanced congestion avoidance with bandwidth estimation\n                        let base_increase = 1.0 / current_cwnd;\n                        let rtt_factor = (0.1 / state.load_rtt_estimate()).min(2.0).max(0.5);\n                        let bandwidth_factor = {\n                            let avg_bw = state.get_avg_bandwidth();\n                            if avg_bw > 0.0 {\n                                let current_bw = *bytes as f64 / state.load_rtt_estimate();\n                                (current_bw / avg_bw).min(2.0).max(0.5)\n                            } else {\n                                1.0\n                            }\n                        };\n                        current_cwnd + base_increase * rtt_factor * bandwidth_factor\n                    };\n\n                    let clamped_cwnd = new_cwnd.min(CWND_MAX).max(CWND_MIN);\n                    \n                    match state.cas_cwnd(current_cwnd, clamped_cwnd) {\n                        Ok(_) => break,\n                        Err(_) => continue, // Retry on contention\n                    }\n                }\n            }\n            NetworkEvent::Loss { timestamp: _ } => {\n                state.losses.fetch_add(1, Ordering::Relaxed);\n                \n                // Lock-free loss handling\n                loop {\n                    let current_cwnd = state.load_cwnd();\n                    let new_ssthresh = (current_cwnd * 0.7).max(CWND_MIN); // Less aggressive than 0.5\n                    let new_cwnd = new_ssthresh;\n                    \n                    state.store_ssthresh(new_ssthresh);\n                    state.in_slow_start.store(false, Ordering::Release);\n                    \n                    match state.cas_cwnd(current_cwnd, new_cwnd) {\n                        Ok(_) => break,\n                        Err(_) => continue,\n                    }\n                }\n            }\n        }\n\n        // Update running averages atomically\n        let current_cwnd = state.load_cwnd();\n        loop {\n            let current_sum_bits = cwnd_sum.load(Ordering::Acquire);\n            let current_sum = f64::from_bits(current_sum_bits);\n            let new_sum = current_sum + current_cwnd;\n            \n            match cwnd_sum.compare_exchange_weak(\n                current_sum_bits,\n                new_sum.to_bits(),\n                Ordering::AcqRel,\n                Ordering::Acquire\n            ) {\n                Ok(_) => {\n                    count.fetch_add(1, Ordering::Relaxed);\n                    break;\n                }\n                Err(_) => continue,\n            }\n        }\n    }\n\n    let final_count = count.load(Ordering::Relaxed);\n    let avg_cwnd = if final_count > 0 {\n        f64::from_bits(cwnd_sum.load(Ordering::Relaxed)) / final_count as f64\n    } else {\n        0.0\n    };\n\n    let first_ts = events.first().map(|e| e.timestamp()).unwrap_or(0.0);\n    let last_ts = events.last().map(|e| e.timestamp()).unwrap_or(1.0);\n    let duration = (last_ts - first_ts).max(1e-9);\n    let bytes_acked = state.bytes_acked.load(Ordering::Relaxed);\n    let throughput = bytes_acked as f64 / duration;\n\n    let losses = state.losses.load(Ordering::Relaxed);\n    let total_sent = bytes_acked + losses;\n    let goodput_ratio = if total_sent > 0 {\n        bytes_acked as f64 / total_sent as f64\n    } else {\n        0.0\n    };\n\n    SimulationResult {\n        throughput,\n        total_losses: losses,\n        avg_cwnd,\n        goodput_ratio,\n    }\n}",
  "score": 270.0,
  "correct": true,
  "generation": 2,
  "parent_id": "d2b6cd187a9db562",
  "island": 1,
  "level_reached": 1,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (42.4s)\n- miri: PASS (92.1s)\n",
  "model": "sonnet"
}