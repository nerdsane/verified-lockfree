{
  "id": "7f587c774a852424",
  "code": "/// Raft Leader Election - Lock-Free Implementation\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, AtomicPtr, Ordering};\nuse std::ptr;\nuse crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\n\npub type ServerId = u64;\npub type Term = u64;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ServerState {\n    Follower,\n    Candidate,\n    Leader,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum RaftError {\n    NotCandidate,\n    AlreadyVoted,\n    StaleTerm,\n    ClusterTooSmall,\n    ServerNotFound,\n}\n\n#[derive(Debug, Clone)]\npub struct VoteRequest {\n    pub term: Term,\n    pub candidate_id: ServerId,\n}\n\n#[derive(Debug, Clone)]\npub struct VoteResponse {\n    pub term: Term,\n    pub vote_granted: bool,\n    pub voter_id: ServerId,\n}\n\n#[derive(Debug, Clone)]\npub struct Heartbeat {\n    pub term: Term,\n    pub leader_id: ServerId,\n}\n\n#[derive(Debug)]\nstruct ServerInner {\n    current_term: AtomicU64,\n    voted_for: AtomicU64, // 0 means None, otherwise ServerId\n    state: AtomicU64, // 0=Follower, 1=Candidate, 2=Leader\n    votes_received: Atomic<Vec<ServerId>>,\n}\n\nimpl ServerInner {\n    fn new() -> Self {\n        Self {\n            current_term: AtomicU64::new(0),\n            voted_for: AtomicU64::new(0),\n            state: AtomicU64::new(0),\n            votes_received: Atomic::new(Vec::new()),\n        }\n    }\n\n    fn get_state(&self) -> ServerState {\n        match self.state.load(Ordering::Acquire) {\n            0 => ServerState::Follower,\n            1 => ServerState::Candidate,\n            2 => ServerState::Leader,\n            _ => ServerState::Follower,\n        }\n    }\n\n    fn set_state(&self, state: ServerState) {\n        let val = match state {\n            ServerState::Follower => 0,\n            ServerState::Candidate => 1,\n            ServerState::Leader => 2,\n        };\n        self.state.store(val, Ordering::Release);\n    }\n\n    fn get_voted_for(&self) -> Option<ServerId> {\n        let val = self.voted_for.load(Ordering::Acquire);\n        if val == 0 { None } else { Some(val) }\n    }\n\n    fn set_voted_for(&self, server_id: Option<ServerId>) {\n        let val = server_id.unwrap_or(0);\n        self.voted_for.store(val, Ordering::Release);\n    }\n}\n\npub struct RaftElection {\n    servers: HashMap<ServerId, ServerInner>,\n    cluster_size: usize,\n    next_id: AtomicU64,\n}\n\nimpl RaftElection {\n    pub fn new(server_ids: &[ServerId]) -> Self {\n        debug_assert!(!server_ids.is_empty(), \"Cluster must have at least one server\");\n        debug_assert!(\n            server_ids.len() % 2 == 1,\n            \"Cluster size should be odd for clean majority\"\n        );\n\n        let mut servers = HashMap::new();\n        for &id in server_ids {\n            servers.insert(id, ServerInner::new());\n        }\n\n        RaftElection {\n            cluster_size: servers.len(),\n            servers,\n            next_id: AtomicU64::new(server_ids.iter().max().copied().unwrap_or(0) + 1),\n        }\n    }\n\n    pub fn cluster_size(&self) -> usize {\n        self.cluster_size\n    }\n\n    pub fn quorum_size(&self) -> usize {\n        self.cluster_size / 2 + 1\n    }\n\n    pub fn get_state(&self, server_id: ServerId) -> Option<ServerState> {\n        self.servers.get(&server_id).map(|s| s.get_state())\n    }\n\n    pub fn get_term(&self, server_id: ServerId) -> Option<Term> {\n        self.servers\n            .get(&server_id)\n            .map(|s| s.current_term.load(Ordering::Acquire))\n    }\n\n    pub fn get_leader(&self) -> Option<ServerId> {\n        for (&id, server) in &self.servers {\n            if server.get_state() == ServerState::Leader {\n                return Some(id);\n            }\n        }\n        None\n    }\n\n    pub fn timeout(&self, server_id: ServerId) -> Result<VoteRequest, RaftError> {\n        let server = self\n            .servers\n            .get(&server_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        loop {\n            let current_term = server.current_term.load(Ordering::Acquire);\n            let current_state = server.get_state();\n\n            if current_state == ServerState::Leader {\n                return Err(RaftError::NotCandidate);\n            }\n\n            let new_term = current_term + 1;\n            \n            // Try to increment term atomically\n            if server.current_term.compare_exchange_weak(\n                current_term,\n                new_term,\n                Ordering::AcqRel,\n                Ordering::Acquire,\n            ).is_ok() {\n                // Successfully incremented term, now update state\n                server.set_state(ServerState::Candidate);\n                server.set_voted_for(Some(server_id));\n                \n                // Reset votes received\n                let guard = epoch::pin();\n                let new_votes = Owned::new(vec![server_id]);\n                server.votes_received.store(new_votes, Ordering::Release);\n                \n                return Ok(VoteRequest {\n                    term: new_term,\n                    candidate_id: server_id,\n                });\n            }\n        }\n    }\n\n    pub fn handle_vote_request(\n        &self,\n        server_id: ServerId,\n        request: &VoteRequest,\n    ) -> Result<VoteResponse, RaftError> {\n        let server = self\n            .servers\n            .get(&server_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        loop {\n            let current_term = server.current_term.load(Ordering::Acquire);\n            let voted_for = server.get_voted_for();\n\n            // If request has higher term, update our term\n            if request.term > current_term {\n                if server.current_term.compare_exchange_weak(\n                    current_term,\n                    request.term,\n                    Ordering::AcqRel,\n                    Ordering::Acquire,\n                ).is_ok() {\n                    server.set_state(ServerState::Follower);\n                    server.set_voted_for(None);\n                    \n                    let guard = epoch::pin();\n                    let new_votes = Owned::new(Vec::new());\n                    server.votes_received.store(new_votes, Ordering::Release);\n                    continue;\n                }\n                continue;\n            }\n\n            let final_term = server.current_term.load(Ordering::Acquire);\n            let vote_granted = request.term >= final_term\n                && (voted_for.is_none() || voted_for == Some(request.candidate_id));\n\n            if vote_granted && request.term == final_term {\n                server.set_voted_for(Some(request.candidate_id));\n            }\n\n            return Ok(VoteResponse {\n                term: final_term,\n                vote_granted,\n                voter_id: server_id,\n            });\n        }\n    }\n\n    pub fn handle_vote_response(\n        &self,\n        candidate_id: ServerId,\n        response: &VoteResponse,\n    ) -> Result<bool, RaftError> {\n        let server = self\n            .servers\n            .get(&candidate_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        let current_term = server.current_term.load(Ordering::Acquire);\n\n        // If response has higher term, step down\n        if response.term > current_term {\n            if server.current_term.compare_exchange_weak(\n                current_term,\n                response.term,\n                Ordering::AcqRel,\n                Ordering::Acquire,\n            ).is_ok() {\n                server.set_state(ServerState::Follower);\n                server.set_voted_for(None);\n                \n                let guard = epoch::pin();\n                let new_votes = Owned::new(Vec::new());\n                server.votes_received.store(new_votes, Ordering::Release);\n            }\n            return Ok(false);\n        }\n\n        // Only process if still a candidate in the same term\n        if server.get_state() != ServerState::Candidate || response.term != current_term {\n            return Ok(false);\n        }\n\n        if response.vote_granted {\n            let guard = epoch::pin();\n            loop {\n                let votes_ptr = server.votes_received.load(Ordering::Acquire, &guard);\n                let votes = unsafe { votes_ptr.as_ref() }.unwrap();\n                \n                if votes.contains(&response.voter_id) {\n                    break;\n                }\n\n                let mut new_votes = votes.clone();\n                new_votes.push(response.voter_id);\n                let new_votes_owned = Owned::new(new_votes);\n                \n                if server.votes_received.compare_exchange_weak(\n                    votes_ptr,\n                    new_votes_owned,\n                    Ordering::AcqRel,\n                    Ordering::Acquire,\n                    &guard,\n                ).is_ok() {\n                    unsafe {\n                        guard.defer_destroy(votes_ptr);\n                    }\n                    break;\n                }\n            }\n        }\n\n        // Check if we have a quorum\n        let guard = epoch::pin();\n        let votes_ptr = server.votes_received.load(Ordering::Acquire, &guard);\n        let votes = unsafe { votes_ptr.as_ref() }.unwrap();\n        let won = votes.len() >= self.quorum_size();\n        \n        if won {\n            server.set_state(ServerState::Leader);\n        }\n\n        Ok(won)\n    }\n\n    pub fn handle_heartbeat(\n        &self,\n        server_id: ServerId,\n        heartbeat: &Heartbeat,\n    ) -> Result<(), RaftError> {\n        let server = self\n            .servers\n            .get(&server_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        let current_term = server.current_term.load(Ordering::Acquire);\n\n        if heartbeat.term >= current_term {\n            if heartbeat.term > current_term {\n                server.current_term.store(heartbeat.term, Ordering::Release);\n                server.set_voted_for(None);\n            }\n            server.set_state(ServerState::Follower);\n            \n            let guard = epoch::pin();\n            let new_votes = Owned::new(Vec::new());\n            server.votes_received.store(new_votes, Ordering::Release);\n        }\n\n        Ok(())\n    }\n\n    pub fn create_heartbeat(&self, leader_id: ServerId) -> Result<Heartbeat, RaftError> {\n        let server = self\n            .servers\n            .get(&leader_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        if server.get_state() != ServerState::Leader {\n            return Err(RaftError::NotCandidate);\n        }\n\n        Ok(Heartbeat {\n            term: server.current_term.load(Ordering::Acquire),\n            leader_id,\n        })\n    }\n\n    pub fn run_election(&self, candidate_id: ServerId) -> Result<bool, RaftError> {\n        let vote_request = self.timeout(candidate_id)?;\n\n        let other_servers: Vec<ServerId> = self\n            .servers\n            .keys()\n            .filter(|&&id| id != candidate_id)\n            .copied()\n            .collect();\n\n        for &other_id in &other_servers {\n            let response = self.handle_vote_request(other_id, &vote_request)?;\n            let won = self.handle_vote_response(candidate_id, &response)?;\n            if won {\n                return Ok(true);\n            }\n        }\n\n        Ok(self.get_state(candidate_id) == Some(ServerState::Leader))\n    }\n}",
  "score": 160.0,
  "correct": false,
  "generation": 1,
  "parent_id": "863c05c721c95705",
  "island": 1,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (31.5s)\n- miri: FAIL (55.3s) â€” error: \"error: Undefined Behavior: trying to retag from <159683> for SharedReadWrite permission at alloc49245[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 14 tests\\ntest tests::tests::test_concurrent_elections_safety ... \\n    Blocking waiting for file lock on package cache\\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling regex-syntax v0.8.9\\n   Compiling rustix v1.1.3\\n   Compiling shlex v1.3.0\\n   Compiling zerocopy v0.8.39\\n   Compiling autocfg v1.5.0\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling tracing-core v0.1.36\\n   Compiling cc v1.2.55\\n   Compiling log v0.4.29\\n   Compiling bitflags v2.10.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling fastrand v2.3.0\\n   Compiling lazy_static v1.5.0\\n   Compiling num-traits v0.2.19\\n   Compiling sharded-slab v0.1.7\\n   Compiling thread_local v1.1.9\\n   Compiling tracing-log v0.2.0\\n   Compiling tracing v0.1.44\\n   Compiling smallvec v1.15.1\\n   Compiling quick-error v1.2.3\\n   Compiling fnv v1.0.7\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling bit-vec v0.8.0\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling rand_core v0.9.5\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling scoped-tls v1.0.1\\n   Compiling rand_xorshift v0.4.0\\n   Compiling rand v0.9.2\\n   Compiling bit-set v0.8.0\\n   Compiling unarray v0.1.4\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-5140882496777752091)\\nwarning: unused import: `AtomicPtr`\\n --> src/lib.rs:3:36\\n  |\\n3 | use std::sync::atomic::{AtomicU64, AtomicPtr, Ordering};\\n  |                                    ^^^^^^^^^\\n  |\\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\\n\\nwarning: unused import: `std::ptr`\\n --> src/lib.rs:4:5\\n  |\\n4 | use std::ptr;\\n  |     ^^^^^^^^\\n\\nwarning: unused import: `Shared`\\n --> src/lib.rs:5:53\\n  |\\n5 | use crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\\n  |                                                     ^^^^^^\\n\\nwarning: unused variable: `guard`\\n   --> src/lib.rs:173:\"\n",
  "model": "sonnet"
}