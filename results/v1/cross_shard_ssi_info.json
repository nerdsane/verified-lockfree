{
  "id": "1c92ead0159fca2f",
  "code": "use std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};\nuse crossbeam_epoch::{self as epoch, Atomic, Owned};\nuse std::ptr;\n\npub type TxnId = u64;\n\n#[derive(Debug, PartialEq)]\npub enum SsiError {\n    WriteConflict,\n    ReadConflict,\n    ShardOutOfRange,\n    TxnNotFound,\n}\n\n#[derive(Clone)]\nstruct TxnState {\n    reads: Vec<(usize, u64)>,\n    writes: Vec<(usize, u64, u64)>,\n    snapshot_versions: Vec<u64>,\n}\n\nstruct ShardData {\n    data: HashMap<u64, u64>,\n    version: u64,\n}\n\nstruct TxnNode {\n    id: TxnId,\n    state: TxnState,\n    next: Atomic<TxnNode>,\n}\n\npub struct CrossShardSsi {\n    shards: Vec<Atomic<ShardData>>,\n    txn_head: Atomic<TxnNode>,\n    next_txn_id: AtomicU64,\n    num_shards: AtomicUsize,\n}\n\nimpl CrossShardSsi {\n    pub fn new(num_shards: usize) -> Self {\n        debug_assert!(num_shards > 0, \"Must have at least one shard\");\n        let shards = (0..num_shards)\n            .map(|_| {\n                Atomic::new(ShardData {\n                    data: HashMap::new(),\n                    version: 0,\n                })\n            })\n            .collect();\n        \n        CrossShardSsi {\n            shards,\n            txn_head: Atomic::null(),\n            next_txn_id: AtomicU64::new(1),\n            num_shards: AtomicUsize::new(num_shards),\n        }\n    }\n\n    pub fn begin_txn(&self) -> TxnId {\n        let id = self.next_txn_id.fetch_add(1, Ordering::Relaxed);\n        let guard = &epoch::pin();\n        \n        let snapshot_versions: Vec<u64> = self.shards\n            .iter()\n            .map(|s| {\n                let shard = s.load(Ordering::Acquire, guard);\n                if shard.is_null() {\n                    0\n                } else {\n                    unsafe { shard.deref().version }\n                }\n            })\n            .collect();\n        \n        let state = TxnState {\n            reads: Vec::new(),\n            writes: Vec::new(),\n            snapshot_versions,\n        };\n        \n        let new_node = Owned::new(TxnNode {\n            id,\n            state,\n            next: Atomic::null(),\n        }).into_shared(guard);\n        \n        loop {\n            let head = self.txn_head.load(Ordering::Acquire, guard);\n            unsafe { new_node.deref().next.store(head, Ordering::Release); }\n            \n            match self.txn_head.compare_exchange(\n                head,\n                new_node,\n                Ordering::Release,\n                Ordering::Acquire,\n                guard,\n            ) {\n                Ok(_) => break,\n                Err(_) => continue,\n            }\n        }\n        \n        id\n    }\n\n    pub fn read(&self, txn: TxnId, shard: usize, key: u64) -> Option<u64> {\n        debug_assert!(shard < self.num_shards.load(Ordering::Relaxed), \"Shard index out of range\");\n        let guard = &epoch::pin();\n        \n        let value = {\n            let shard_data = self.shards[shard].load(Ordering::Acquire, guard);\n            if shard_data.is_null() {\n                None\n            } else {\n                unsafe { shard_data.deref().data.get(&key).copied() }\n            }\n        };\n        \n        self.update_txn_state(txn, |state| {\n            state.reads.push((shard, key));\n        }, guard);\n        \n        value\n    }\n\n    pub fn write(&self, txn: TxnId, shard: usize, key: u64, value: u64) {\n        debug_assert!(shard < self.num_shards.load(Ordering::Relaxed), \"Shard index out of range\");\n        let guard = &epoch::pin();\n        \n        self.update_txn_state(txn, |state| {\n            state.writes.push((shard, key, value));\n        }, guard);\n    }\n\n    pub fn commit(&self, txn: TxnId) -> Result<(), SsiError> {\n        let guard = &epoch::pin();\n        \n        let state = match self.remove_txn(txn, guard) {\n            Some(s) => s,\n            None => return Err(SsiError::TxnNotFound),\n        };\n        \n        let mut involved: Vec<usize> = state.reads.iter()\n            .map(|(s, _)| *s)\n            .chain(state.writes.iter().map(|(s, _, _)| *s))\n            .collect();\n        involved.sort();\n        involved.dedup();\n        \n        // Try to atomically update all shards\n        for &shard_idx in &involved {\n            let old_shard = self.shards[shard_idx].load(Ordering::Acquire, guard);\n            if old_shard.is_null() {\n                continue;\n            }\n            \n            let old_version = unsafe { old_shard.deref().version };\n            if old_version != state.snapshot_versions[shard_idx] {\n                return Err(SsiError::WriteConflict);\n            }\n        }\n        \n        // Apply writes\n        for &shard_idx in &involved {\n            let has_writes = state.writes.iter().any(|(s, _, _)| *s == shard_idx);\n            if !has_writes {\n                continue;\n            }\n            \n            loop {\n                let old_shard = self.shards[shard_idx].load(Ordering::Acquire, guard);\n                if old_shard.is_null() {\n                    break;\n                }\n                \n                let mut new_data = unsafe { old_shard.deref().data.clone() };\n                let old_version = unsafe { old_shard.deref().version };\n                \n                if old_version != state.snapshot_versions[shard_idx] {\n                    return Err(SsiError::WriteConflict);\n                }\n                \n                for &(s, key, value) in &state.writes {\n                    if s == shard_idx {\n                        new_data.insert(key, value);\n                    }\n                }\n                \n                let new_shard = Owned::new(ShardData {\n                    data: new_data,\n                    version: old_version + 1,\n                });\n                \n                match self.shards[shard_idx].compare_exchange(\n                    old_shard,\n                    new_shard,\n                    Ordering::Release,\n                    Ordering::Acquire,\n                    guard,\n                ) {\n                    Ok(_) => {\n                        unsafe { guard.defer_destroy(old_shard) };\n                        break;\n                    }\n                    Err(_) => continue,\n                }\n            }\n        }\n        \n        Ok(())\n    }\n\n    pub fn abort(&self, txn: TxnId) {\n        let guard = &epoch::pin();\n        self.remove_txn(txn, guard);\n    }\n    \n    fn update_txn_state<F>(&self, txn_id: TxnId, f: F, guard: &epoch::Guard) \n    where F: FnOnce(&mut TxnState) \n    {\n        let mut current = self.txn_head.load(Ordering::Acquire, guard);\n        \n        while !current.is_null() {\n            let node = unsafe { current.deref() };\n            if node.id == txn_id {\n                // Found it - create new state\n                let mut new_state = node.state.clone();\n                f(&mut new_state);\n                \n                // Try to update atomically\n                let new_node = Owned::new(TxnNode {\n                    id: txn_id,\n                    state: new_state,\n                    next: Atomic::null(),\n                }).into_shared(guard);\n                \n                // Re-insert at head\n                loop {\n                    let head = self.txn_head.load(Ordering::Acquire, guard);\n                    unsafe { new_node.deref().next.store(head, Ordering::Release); }\n                    \n                    match self.txn_head.compare_exchange(\n                        head,\n                        new_node,\n                        Ordering::Release,\n                        Ordering::Acquire,\n                        guard,\n                    ) {\n                        Ok(_) => return,\n                        Err(_) => continue,\n                    }\n                }\n            }\n            current = node.next.load(Ordering::Acquire, guard);\n        }\n    }\n    \n    fn remove_txn(&self, txn_id: TxnId, guard: &epoch::Guard) -> Option<TxnState> {\n        let mut prev: *const TxnNode = ptr::null();\n        let mut current = self.txn_head.load(Ordering::Acquire, guard);\n        \n        while !current.is_null() {\n            let node = unsafe { current.deref() };\n            if node.id == txn_id {\n                let state = node.state.clone();\n                let next = node.next.load(Ordering::Acquire, guard);\n                \n                if prev.is_null() {\n                    // Remove from head\n                    match self.txn_head.compare_exchange(\n                        current,\n                        next,\n                        Ordering::Release,\n                        Ordering::Acquire,\n                        guard,\n                    ) {\n                        Ok(_) => {\n                            unsafe { guard.defer_destroy(current) };\n                            return Some(state);\n                        }\n                        Err(_) => return self.remove_txn(txn_id, guard),\n                    }\n                } else {\n                    // Remove from middle\n                    unsafe {\n                        let prev_node = &*prev as &TxnNode;\n                        match prev_node.next.compare_exchange(\n                            current,\n                            next,\n                            Ordering::Release,\n                            Ordering::Acquire,\n                            guard,\n                        ) {\n                            Ok(_) => {\n                                guard.defer_destroy(current);\n                                return Some(state);\n                            }\n                            Err(_) => return self.remove_txn(txn_id, guard),\n                        }\n                    }\n                }\n            }\n            prev = current.as_raw();\n            current = node.next.load(Ordering::Acquire, guard);\n        }\n        \n        None\n    }\n}",
  "score": 160.0,
  "correct": false,
  "generation": 3,
  "parent_id": "0cce201aaf0e7466",
  "island": 0,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (42.8s)\n- miri: FAIL (47.9s) â€” error: \"error: Undefined Behavior: trying to retag from <140326> for SharedReadWrite permission at alloc42601[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 8 tests\\ntest tests::tests::test_abort_discards_writes ... \\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling zerocopy v0.8.39\\n   Compiling rustix v1.1.3\\n   Compiling regex-syntax v0.8.9\\n   Compiling shlex v1.3.0\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling autocfg v1.5.0\\n   Compiling cc v1.2.55\\n   Compiling log v0.4.29\\n   Compiling bitflags v2.10.0\\n   Compiling tracing-core v0.1.36\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling fastrand v2.3.0\\n   Compiling num-traits v0.2.19\\n   Compiling lazy_static v1.5.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling sharded-slab v0.1.7\\n   Compiling thread_local v1.1.9\\n   Compiling fnv v1.0.7\\n   Compiling smallvec v1.15.1\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling tracing-log v0.2.0\\n   Compiling tracing v0.1.44\\n   Compiling bit-vec v0.8.0\\n   Compiling quick-error v1.2.3\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling bit-set v0.8.0\\n   Compiling rand_core v0.9.5\\n   Compiling scoped-tls v1.0.1\\n   Compiling unarray v0.1.4\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling rand_xorshift v0.4.0\\n   Compiling rand v0.9.2\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-10788444730949413701)\\n   Compiling generator v0.8.8\\n   Compiling tempfile v3.24.0\\n   Compiling regex-automata v0.4.14\\n   Compiling rusty-fork v0.3.1\\n   Compiling ppv-lite86 v0.2.21\\n   Compiling rand_chacha v0.9.0\\n   Compiling proptest v1.10.0\\n   Compiling matchers v0.2.0\\n   Compiling tracing-subscriber v0.3.22\\n   Compiling loom v0.7.2\\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 43.91s\\n     Running unittests src/lib.rs (target/miri/aarch64-apple-darwin/debug/deps/vf_temp_crate-3d71d4f29c481fe3)\\nwarning: integer-to-pointer cast\\n   --> /Users/sesh.nalla/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-epoch-0.9.18/src/atomic.rs:20\"\n",
  "model": "opus"
}