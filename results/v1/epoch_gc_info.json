{
  "id": "7fe7eb857766a3cd",
  "code": "use std::sync::atomic::{AtomicUsize, AtomicPtr, Ordering};\nuse std::sync::Arc;\nuse std::ptr;\n\npub struct EpochGc {\n    inner: Arc<GcState>,\n}\n\nstruct GcState {\n    deferred: AtomicPtr<DeferredNode>,\n    pinned: AtomicUsize,\n}\n\nstruct DeferredNode {\n    next: *mut DeferredNode,\n    func: Box<dyn FnOnce() + Send + 'static>,\n}\n\npub struct Guard {\n    gc: Arc<GcState>,\n}\n\nimpl EpochGc {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(GcState {\n                deferred: AtomicPtr::new(ptr::null_mut()),\n                pinned: AtomicUsize::new(0),\n            }),\n        }\n    }\n\n    pub fn pin(&self) -> Guard {\n        self.inner.pinned.fetch_add(1, Ordering::AcqRel);\n        Guard {\n            gc: Arc::clone(&self.inner),\n        }\n    }\n\n    pub fn retire<T>(&self, ptr: *mut T)\n    where\n        T: Send + 'static,\n    {\n        let addr = ptr as usize;\n        let func = Box::new(move || unsafe {\n            let ptr = addr as *mut T;\n            let _ = Box::from_raw(ptr);\n        });\n\n        let node = Box::into_raw(Box::new(DeferredNode {\n            next: ptr::null_mut(),\n            func,\n        }));\n\n        loop {\n            let head = self.inner.deferred.load(Ordering::Acquire);\n            unsafe {\n                (*node).next = head;\n            }\n            match self.inner.deferred.compare_exchange(\n                head,\n                node,\n                Ordering::Release,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => break,\n                Err(_) => continue,\n            }\n        }\n    }\n\n    pub fn collect(&self) {\n        if self.inner.pinned.load(Ordering::Acquire) == 0 {\n            let head = self.inner.deferred.swap(ptr::null_mut(), Ordering::AcqRel);\n            \n            if !head.is_null() {\n                let mut current = head;\n                let mut nodes = Vec::new();\n                \n                unsafe {\n                    while !current.is_null() {\n                        let node = Box::from_raw(current);\n                        current = node.next;\n                        nodes.push(node);\n                    }\n                }\n                \n                for node in nodes {\n                    (node.func)();\n                }\n            }\n        }\n    }\n}\n\nimpl Guard {\n    pub fn defer(&self, f: impl FnOnce() + Send + 'static) {\n        let node = Box::into_raw(Box::new(DeferredNode {\n            next: ptr::null_mut(),\n            func: Box::new(f),\n        }));\n\n        loop {\n            let head = self.gc.deferred.load(Ordering::Acquire);\n            unsafe {\n                (*node).next = head;\n            }\n            match self.gc.deferred.compare_exchange(\n                head,\n                node,\n                Ordering::Release,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => break,\n                Err(_) => continue,\n            }\n        }\n    }\n}\n\nimpl Drop for Guard {\n    fn drop(&mut self) {\n        self.gc.pinned.fetch_sub(1, Ordering::AcqRel);\n    }\n}\n\nunsafe impl Send for GcState {}\nunsafe impl Sync for GcState {}",
  "score": 270.0,
  "correct": true,
  "generation": 7,
  "parent_id": "b630c9ed90c02c35",
  "island": 0,
  "level_reached": 1,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (40.7s)\n- miri: PASS (101.0s)\n",
  "model": "opus"
}