{
  "id": "eafd3a3dd44c893c",
  "code": "use crossbeam_epoch::{self as epoch, Atomic, Guard, Owned, Shared};\nuse std::cmp::Ordering;\nuse std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n\nstruct Node<T> {\n    data: T,\n    next: Atomic<Node<T>>,\n}\n\npub struct ConcurrentLinkedList<T> {\n    head: Atomic<Node<T>>,\n}\n\nimpl<T: Ord> ConcurrentLinkedList<T> {\n    pub fn new() -> Self {\n        ConcurrentLinkedList {\n            head: Atomic::null(),\n        }\n    }\n\n    pub fn insert(&self, value: T) -> bool {\n        let guard = &epoch::pin();\n        let mut new_node = Owned::new(Node {\n            data: value,\n            next: Atomic::null(),\n        });\n\n        loop {\n            let (prev, curr) = self.find(&new_node.data, guard);\n            \n            if !curr.is_null() {\n                unsafe {\n                    if curr.deref().data == new_node.data {\n                        return false;\n                    }\n                }\n            }\n\n            new_node.next.store(curr, Relaxed);\n\n            match if prev.is_null() {\n                self.head.compare_exchange(curr, new_node, Release, Acquire, guard)\n            } else {\n                unsafe {\n                    prev.deref().next.compare_exchange(curr, new_node, Release, Acquire, guard)\n                }\n            } {\n                Ok(_) => return true,\n                Err(e) => {\n                    new_node = e.new;\n                }\n            }\n        }\n    }\n\n    pub fn remove(&self, value: &T) -> bool {\n        let guard = &epoch::pin();\n        \n        loop {\n            let (prev, curr) = self.find(value, guard);\n            \n            if curr.is_null() {\n                return false;\n            }\n\n            let curr_node = unsafe { curr.deref() };\n            if curr_node.data != *value {\n                return false;\n            }\n\n            let next = curr_node.next.load(Acquire, guard);\n\n            match if prev.is_null() {\n                self.head.compare_exchange(curr, next, Release, Acquire, guard)\n            } else {\n                unsafe {\n                    prev.deref().next.compare_exchange(curr, next, Release, Acquire, guard)\n                }\n            } {\n                Ok(_) => {\n                    unsafe { guard.defer_destroy(curr) };\n                    return true;\n                }\n                Err(_) => continue,\n            }\n        }\n    }\n\n    pub fn contains(&self, value: &T) -> bool {\n        let guard = &epoch::pin();\n        let (_, curr) = self.find(value, guard);\n        \n        if curr.is_null() {\n            false\n        } else {\n            unsafe { curr.deref().data == *value }\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        let guard = &epoch::pin();\n        let mut count = 0;\n        let mut curr = self.head.load(Acquire, guard);\n        \n        while !curr.is_null() {\n            count += 1;\n            curr = unsafe { curr.deref().next.load(Acquire, guard) };\n        }\n        \n        count\n    }\n\n    pub fn is_empty(&self) -> bool {\n        let guard = &epoch::pin();\n        self.head.load(Acquire, guard).is_null()\n    }\n\n    fn find<'g>(&self, value: &T, guard: &'g Guard) -> (Shared<'g, Node<T>>, Shared<'g, Node<T>>) {\n        let mut prev = Shared::null();\n        let mut curr = self.head.load(Acquire, guard);\n\n        while !curr.is_null() {\n            let curr_node = unsafe { curr.deref() };\n            \n            match curr_node.data.cmp(value) {\n                Ordering::Less => {\n                    prev = curr;\n                    curr = curr_node.next.load(Acquire, guard);\n                }\n                _ => break,\n            }\n        }\n\n        (prev, curr)\n    }\n}\n\nimpl<T> Drop for ConcurrentLinkedList<T> {\n    fn drop(&mut self) {\n        let guard = &epoch::pin();\n        let mut curr = self.head.load(Relaxed, guard);\n        \n        while !curr.is_null() {\n            let next = unsafe { curr.deref().next.load(Relaxed, guard) };\n            unsafe {\n                drop(curr.into_owned());\n            }\n            curr = next;\n        }\n    }\n}",
  "score": 160.0,
  "correct": false,
  "generation": 2,
  "parent_id": "38fee1e8d6c29842",
  "island": 0,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (36.3s)\n- miri: FAIL (52.4s) â€” error: \"error: Undefined Behavior: trying to retag from <138017> for SharedReadWrite permission at alloc41850[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 7 tests\\ntest tests::tests::test_concurrent_insert_and_remove ... \\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling zerocopy v0.8.39\\n   Compiling shlex v1.3.0\\n   Compiling rustix v1.1.3\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling regex-syntax v0.8.9\\n   Compiling log v0.4.29\\n   Compiling tracing-core v0.1.36\\n   Compiling cc v1.2.55\\n   Compiling bitflags v2.10.0\\n   Compiling autocfg v1.5.0\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling lazy_static v1.5.0\\n   Compiling fastrand v2.3.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling sharded-slab v0.1.7\\n   Compiling tracing-log v0.2.0\\n   Compiling tracing v0.1.44\\n   Compiling num-traits v0.2.19\\n   Compiling thread_local v1.1.9\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling bit-vec v0.8.0\\n   Compiling smallvec v1.15.1\\n   Compiling quick-error v1.2.3\\n   Compiling fnv v1.0.7\\n   Compiling unarray v0.1.4\\n   Compiling scoped-tls v1.0.1\\n   Compiling errno v0.3.14\\n   Compiling wait-timeout v0.2.1\\n   Compiling bit-set v0.8.0\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling rand_core v0.9.5\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-16582418631626535499)\\n   Compiling rand_xorshift v0.4.0\\n   Compiling rand v0.9.2\\n   Compiling generator v0.8.8\\n   Compiling tempfile v3.24.0\\n   Compiling rusty-fork v0.3.1\\n   Compiling regex-automata v0.4.14\\n   Compiling ppv-lite86 v0.2.21\\n   Compiling matchers v0.2.0\\n   Compiling tracing-subscriber v0.3.22\\n   Compiling rand_chacha v0.9.0\\n   Compiling proptest v1.10.0\\n   Compiling loom v0.7.2\\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 41.44s\\n     Running unittests src/lib.rs (target/miri/aarch64-apple-darwin/debug/deps/vf_temp_crate-3d71d4f29c481fe3)\\nwarning: unused import: `std::collections::HashSet`\\n   --> src/lib.rs:173:9\\n    |\\n173 |     use std::collections::HashSet;\\n    |         ^^^^^^\"\n",
  "model": "opus"
}