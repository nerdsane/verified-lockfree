{
  "id": "1299b267d06a1c4e",
  "code": "/// Two-Phase Commit - Lock-Free Implementation\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};\nuse crossbeam_epoch::{self as epoch, Atomic, Guard, Owned};\n\npub type RmId = u64;\npub type TxnId = u64;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum RmState {\n    Working,\n    Prepared,\n    Committed,\n    Aborted,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TmState {\n    Init,\n    Preparing,\n    Committed,\n    Aborted,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TpcError {\n    RmNotFound,\n    TxnNotFound,\n    InvalidState,\n    AlreadyDecided,\n    NotAllPrepared,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TmDecision {\n    Commit,\n    Abort,\n}\n\nstruct TxnInner {\n    tm_state: AtomicUsize,\n    rm_states: HashMap<RmId, AtomicUsize>,\n    prepared_count: AtomicUsize,\n    total_rms: usize,\n}\n\nimpl TxnInner {\n    fn new(rm_ids: &[RmId]) -> Self {\n        let rm_states = rm_ids.iter()\n            .map(|&id| (id, AtomicUsize::new(RmState::Working as usize)))\n            .collect();\n        \n        TxnInner {\n            tm_state: AtomicUsize::new(TmState::Init as usize),\n            rm_states,\n            prepared_count: AtomicUsize::new(0),\n            total_rms: rm_ids.len(),\n        }\n    }\n\n    fn get_tm_state(&self) -> TmState {\n        match self.tm_state.load(Ordering::Acquire) {\n            0 => TmState::Init,\n            1 => TmState::Preparing,\n            2 => TmState::Committed,\n            3 => TmState::Aborted,\n            _ => unreachable!(),\n        }\n    }\n\n    fn set_tm_state(&self, from: TmState, to: TmState) -> bool {\n        let from_val = from as usize;\n        let to_val = to as usize;\n        self.tm_state.compare_exchange_weak(from_val, to_val, Ordering::AcqRel, Ordering::Acquire).is_ok()\n    }\n\n    fn get_rm_state(&self, rm_id: RmId) -> Option<RmState> {\n        self.rm_states.get(&rm_id).map(|atomic| {\n            match atomic.load(Ordering::Acquire) {\n                0 => RmState::Working,\n                1 => RmState::Prepared,\n                2 => RmState::Committed,\n                3 => RmState::Aborted,\n                _ => unreachable!(),\n            }\n        })\n    }\n\n    fn set_rm_state(&self, rm_id: RmId, from: RmState, to: RmState) -> bool {\n        if let Some(atomic) = self.rm_states.get(&rm_id) {\n            let from_val = from as usize;\n            let to_val = to as usize;\n            atomic.compare_exchange_weak(from_val, to_val, Ordering::AcqRel, Ordering::Acquire).is_ok()\n        } else {\n            false\n        }\n    }\n}\n\nstruct TxnNode {\n    txn_id: TxnId,\n    inner: TxnInner,\n    next: Atomic<TxnNode>,\n}\n\nimpl TxnNode {\n    fn new(txn_id: TxnId, rm_ids: &[RmId]) -> Self {\n        TxnNode {\n            txn_id,\n            inner: TxnInner::new(rm_ids),\n            next: Atomic::null(),\n        }\n    }\n}\n\npub struct TwoPhaseCommit {\n    rm_ids: Vec<RmId>,\n    head: Atomic<TxnNode>,\n    next_txn_id: AtomicU64,\n}\n\nimpl TwoPhaseCommit {\n    pub fn new(rm_ids: &[RmId]) -> Self {\n        debug_assert!(!rm_ids.is_empty(), \"Must have at least one resource manager\");\n\n        TwoPhaseCommit {\n            rm_ids: rm_ids.to_vec(),\n            head: Atomic::null(),\n            next_txn_id: AtomicU64::new(1),\n        }\n    }\n\n    pub fn rm_count(&self) -> usize {\n        self.rm_ids.len()\n    }\n\n    fn find_txn<'g>(&self, txn_id: TxnId, guard: &'g Guard) -> Option<&'g TxnNode> {\n        let mut current = self.head.load(Ordering::Acquire, guard);\n        \n        while !current.is_null() {\n            let node = unsafe { current.deref() };\n            if node.txn_id == txn_id {\n                return Some(node);\n            }\n            current = node.next.load(Ordering::Acquire, guard);\n        }\n        None\n    }\n\n    pub fn begin(&self) -> TxnId {\n        let guard = epoch::pin();\n        let txn_id = self.next_txn_id.fetch_add(1, Ordering::Relaxed);\n        \n        loop {\n            let new_node = Owned::new(TxnNode::new(txn_id, &self.rm_ids));\n            let head = self.head.load(Ordering::Acquire, &guard);\n            new_node.next.store(head, Ordering::Relaxed);\n            \n            match self.head.compare_exchange_weak(\n                head,\n                new_node,\n                Ordering::Release,\n                Ordering::Relaxed,\n                &guard,\n            ) {\n                Ok(_) => break,\n                Err(e) => {\n                    // Continue with a new node\n                    continue;\n                }\n            }\n        }\n        \n        txn_id\n    }\n\n    pub fn get_tm_state(&self, txn_id: TxnId) -> Option<TmState> {\n        let guard = epoch::pin();\n        self.find_txn(txn_id, &guard).map(|node| node.inner.get_tm_state())\n    }\n\n    pub fn get_rm_state(&self, txn_id: TxnId, rm_id: RmId) -> Option<RmState> {\n        let guard = epoch::pin();\n        self.find_txn(txn_id, &guard)?.inner.get_rm_state(rm_id)\n    }\n\n    pub fn tm_prepare(&self, txn_id: TxnId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        if node.inner.set_tm_state(TmState::Init, TmState::Preparing) {\n            Ok(())\n        } else {\n            Err(TpcError::InvalidState)\n        }\n    }\n\n    pub fn rm_prepare(&self, txn_id: TxnId, rm_id: RmId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        if node.inner.set_rm_state(rm_id, RmState::Working, RmState::Prepared) {\n            node.inner.prepared_count.fetch_add(1, Ordering::AcqRel);\n            Ok(())\n        } else {\n            let current_state = node.inner.get_rm_state(rm_id).ok_or(TpcError::RmNotFound)?;\n            if current_state != RmState::Working {\n                Err(TpcError::InvalidState)\n            } else {\n                Err(TpcError::RmNotFound)\n            }\n        }\n    }\n\n    pub fn rm_choose_to_abort(&self, txn_id: TxnId, rm_id: RmId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        if node.inner.set_rm_state(rm_id, RmState::Working, RmState::Aborted) {\n            Ok(())\n        } else {\n            let current_state = node.inner.get_rm_state(rm_id).ok_or(TpcError::RmNotFound)?;\n            if current_state != RmState::Working {\n                Err(TpcError::InvalidState)\n            } else {\n                Err(TpcError::RmNotFound)\n            }\n        }\n    }\n\n    pub fn tm_commit(&self, txn_id: TxnId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        if node.inner.get_tm_state() != TmState::Preparing {\n            return Err(TpcError::InvalidState);\n        }\n        \n        let prepared_count = node.inner.prepared_count.load(Ordering::Acquire);\n        if prepared_count != node.inner.total_rms {\n            return Err(TpcError::NotAllPrepared);\n        }\n        \n        if node.inner.set_tm_state(TmState::Preparing, TmState::Committed) {\n            Ok(())\n        } else {\n            Err(TpcError::InvalidState)\n        }\n    }\n\n    pub fn tm_abort(&self, txn_id: TxnId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        let current_state = node.inner.get_tm_state();\n        if current_state == TmState::Committed || current_state == TmState::Aborted {\n            return Err(TpcError::AlreadyDecided);\n        }\n        \n        // Try to abort from any valid state\n        match current_state {\n            TmState::Init => {\n                if node.inner.set_tm_state(TmState::Init, TmState::Aborted) {\n                    Ok(())\n                } else {\n                    Err(TpcError::InvalidState)\n                }\n            }\n            TmState::Preparing => {\n                if node.inner.set_tm_state(TmState::Preparing, TmState::Aborted) {\n                    Ok(())\n                } else {\n                    Err(TpcError::InvalidState)\n                }\n            }\n            _ => Err(TpcError::InvalidState)\n        }\n    }\n\n    pub fn rm_rcv_commit(&self, txn_id: TxnId, rm_id: RmId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        if node.inner.get_tm_state() != TmState::Committed {\n            return Err(TpcError::InvalidState);\n        }\n        \n        if node.inner.set_rm_state(rm_id, RmState::Prepared, RmState::Committed) {\n            Ok(())\n        } else {\n            Err(TpcError::RmNotFound)\n        }\n    }\n\n    pub fn rm_rcv_abort(&self, txn_id: TxnId, rm_id: RmId) -> Result<(), TpcError> {\n        let guard = epoch::pin();\n        let node = self.find_txn(txn_id, &guard).ok_or(TpcError::TxnNotFound)?;\n        \n        if node.inner.get_tm_state() != TmState::Aborted {\n            return Err(TpcError::InvalidState);\n        }\n        \n        let current_state = node.inner.get_rm_state(rm_id).ok_or(TpcError::RmNotFound)?;\n        \n        match current_state {\n            RmState::Working => {\n                node.inner.set_rm_state(rm_id, RmState::Working, RmState::Aborted);\n            }\n            RmState::Prepared => {\n                node.inner.set_rm_state(rm_id, RmState::Prepared, RmState::Aborted);\n            }\n            RmState::Aborted => {\n                // Already aborted, that's fine\n            }\n            _ => return Err(TpcError::InvalidState),\n        }\n        \n        Ok(())\n    }\n\n    pub fn run_commit(&self, txn_id: TxnId) -> Result<TmDecision, TpcError> {\n        // Phase 1: Prepare\n        self.tm_prepare(txn_id)?;\n\n        // All RMs vote yes\n        let rm_ids = self.rm_ids.clone();\n        for &rm_id in &rm_ids {\n            self.rm_prepare(txn_id, rm_id)?;\n        }\n\n        // Phase 2: Commit\n        self.tm_commit(txn_id)?;\n\n        // Deliver commit to all RMs\n        for &rm_id in &rm_ids {\n            self.rm_rcv_commit(txn_id, rm_id)?;\n        }\n\n        Ok(TmDecision::Commit)\n    }\n\n    pub fn run_abort(&self, txn_id: TxnId, aborting_rm: RmId) -> Result<TmDecision, TpcError> {\n        // Phase 1: Prepare\n        self.tm_prepare(txn_id)?;\n\n        // RMs vote; aborting_rm votes no\n        let rm_ids = self.rm_ids.clone();\n        for &rm_id in &rm_ids {\n            if rm_id == aborting_rm {\n                self.rm_choose_to_abort(txn_id, rm_id)?;\n            } else {\n                self.rm_prepare(txn_id, rm_id)?;\n            }\n        }\n\n        // Phase 2: Abort\n        self.tm_abort(txn_id)?;\n\n        // Deliver abort to all RMs\n        for &rm_id in &rm_ids {\n            let state = self.get_rm_state(txn_id, rm_id);\n            if state != Some(RmState::Aborted) {\n                self.rm_rcv_abort(txn_id, rm_id)?;\n            }\n        }\n\n        Ok(TmDecision::Abort)\n    }\n}",
  "score": 160.0,
  "correct": false,
  "generation": 2,
  "parent_id": "abad8acc5911fb0a",
  "island": 1,
  "level_reached": 0,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (30.9s)\n- miri: FAIL (65.9s) â€” error: \"error: Undefined Behavior: trying to retag from <141704> for SharedReadWrite permission at alloc43064[0x8], but that tag does not exist in the borrow stack for this location\"\n  output: \"\\nrunning 15 tests\\ntest tests::tests::test_abort_on_rm_failure ... \\n    Blocking waiting for file lock on package cache\\n   Compiling libc v0.2.180\\n   Compiling cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n   Compiling once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling shlex v1.3.0\\n   Compiling zerocopy v0.8.39\\n   Compiling regex-syntax v0.8.9\\n   Compiling find-msvc-tools v0.1.9\\n   Compiling rustix v1.1.3\\n   Compiling crossbeam-utils v0.8.21\\n   Compiling cc v1.2.55\\n   Compiling log v0.4.29\\n   Compiling bitflags v2.10.0\\n   Compiling tracing-core v0.1.36\\n   Compiling autocfg v1.5.0\\n   Compiling pin-project-lite v0.2.16\\n   Compiling fastrand v2.3.0\\n   Compiling lazy_static v1.5.0\\n   Compiling sharded-slab v0.1.7\\n   Compiling thread_local v1.1.9\\n   Compiling num-traits v0.2.19\\n   Compiling bit-vec v0.8.0\\n   Compiling tracing v0.1.44\\n   Compiling errno v0.3.14\\n   Compiling rand_core v0.9.5\\n   Compiling wait-timeout v0.2.1\\n   Compiling tracing-log v0.2.0\\n   Compiling fnv v1.0.7\\n   Compiling nu-ansi-term v0.50.3\\n   Compiling quick-error v1.2.3\\n   Compiling smallvec v1.15.1\\n   Compiling rand_xorshift v0.4.0\\n   Compiling rand v0.9.2\\n   Compiling bit-set v0.8.0\\n   Compiling crossbeam-epoch v0.9.18\\n   Compiling scoped-tls v1.0.1\\n   Compiling unarray v0.1.4\\n   Compiling vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-16784848128833774805)\\nwarning: unused variable: `e`\\n   --> src/lib.rs:167:21\\n    |\\n167 |                 Err(e) => {\\n    |                     ^ help: if this is intentional, prefix it with an underscore: `_e`\\n    |\\n    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\\n\\nwarning: `vf-temp-crate` (lib) generated 1 warning (run `cargo fix --lib -p vf-temp-crate` to apply 1 suggestion)\\n   Compiling generator v0.8.8\\n   Compiling tempfile v3.24.0\\n   Compiling regex-automata v0.4.14\\n   Compiling rusty-fork v0.3.1\\n   Compiling ppv-lite86 v0.2.21\\n   Compiling matchers v0.2.0\\n   Compiling tracing\"\n",
  "model": "sonnet"
}