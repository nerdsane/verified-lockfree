{
  "id": "a713de4677449455",
  "code": "```rust\n/// Raft Consensus - Lock-free implementation using atomics and crossbeam-epoch\nuse std::sync::atomic::{AtomicU64, AtomicU8, AtomicBool, Ordering};\nuse std::sync::Arc;\nuse crossbeam_epoch::{self as epoch, Atomic, Owned, Shared, Guard};\nuse std::collections::HashMap;\n\npub type NodeId = u64;\npub type Term = u64;\npub type LogIndex = u64;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum NodeState {\n    Follower = 0,\n    Candidate = 1,\n    Leader = 2,\n}\n\nimpl From<u8> for NodeState {\n    fn from(v: u8) -> Self {\n        match v {\n            0 => NodeState::Follower,\n            1 => NodeState::Candidate,\n            2 => NodeState::Leader,\n            _ => NodeState::Follower,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum RaftError {\n    NotLeader,\n    NotCandidate,\n    StaleTerm,\n    NodeNotFound,\n    LogInconsistency,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LogEntry {\n    pub index: LogIndex,\n    pub term: Term,\n    pub data: Vec<u8>,\n}\n\n#[derive(Debug, Clone)]\npub enum Message {\n    RequestVote {\n        term: Term,\n        candidate_id: NodeId,\n        last_log_index: LogIndex,\n        last_log_term: Term,\n    },\n    RequestVoteResponse {\n        term: Term,\n        voter_id: NodeId,\n        vote_granted: bool,\n    },\n    AppendEntries {\n        term: Term,\n        leader_id: NodeId,\n        prev_log_index: LogIndex,\n        prev_log_term: Term,\n        entries: Vec<LogEntry>,\n        leader_commit: LogIndex,\n    },\n    AppendEntriesResponse {\n        term: Term,\n        follower_id: NodeId,\n        success: bool,\n        match_index: LogIndex,\n    },\n}\n\n#[derive(Debug, Clone, Default)]\npub struct Ready {\n    pub messages: Vec<(NodeId, Message)>,\n    pub committed_entries: Vec<LogEntry>,\n    pub should_persist: bool,\n}\n\n#[derive(Clone)]\nstruct LogState {\n    entries: Vec<LogEntry>,\n    commit_index: LogIndex,\n    last_applied: LogIndex,\n}\n\n#[derive(Clone)]\nstruct LeaderState {\n    next_index: HashMap<NodeId, LogIndex>,\n    match_index: HashMap<NodeId, LogIndex>,\n}\n\n#[derive(Clone)]\nstruct ElectionState {\n    votes_received: Vec<NodeId>,\n    voted_for: Option<NodeId>,\n}\n\n#[derive(Clone)]\nstruct NodeData {\n    log_state: LogState,\n    leader_state: LeaderState,\n    election_state: ElectionState,\n    pending_messages: Vec<(NodeId, Message)>,\n    pending_committed: Vec<LogEntry>,\n}\n\npub struct RaftNode {\n    id: NodeId,\n    peers: Vec<NodeId>,\n    state: AtomicU8,\n    current_term: AtomicU64,\n    election_elapsed: AtomicU64,\n    heartbeat_elapsed: AtomicU64,\n    election_timeout: u64,\n    heartbeat_interval: u64,\n    data: Atomic<NodeData>,\n}\n\nimpl RaftNode {\n    pub fn new(id: NodeId, peers: Vec<NodeId>) -> Self {\n        debug_assert!(!peers.is_empty(), \"Must have at least one peer\");\n        let cluster_size = peers.len() + 1;\n        debug_assert!(\n            cluster_size % 2 == 1,\n            \"Cluster size should be odd for clean majority\"\n        );\n\n        let initial_data = NodeData {\n            log_state: LogState {\n                entries: Vec::new(),\n                commit_index: 0,\n                last_applied: 0,\n            },\n            leader_state: LeaderState {\n                next_index: HashMap::new(),\n                match_index: HashMap::new(),\n            },\n            election_state: ElectionState {\n                votes_received: Vec::new(),\n                voted_for: None,\n            },\n            pending_messages: Vec::new(),\n            pending_committed: Vec::new(),\n        };\n\n        RaftNode {\n            id,\n            peers,\n            state: AtomicU8::new(NodeState::Follower as u8),\n            current_term: AtomicU64::new(0),\n            election_elapsed: AtomicU64::new(0),\n            heartbeat_elapsed: AtomicU64::new(0),\n            election_timeout: 10,\n            heartbeat_interval: 3,\n            data: Atomic::new(initial_data),\n        }\n    }\n\n    pub fn id(&self) -> NodeId {\n        self.id\n    }\n\n    pub fn state(&self) -> NodeState {\n        NodeState::from(self.state.load(Ordering::Acquire))\n    }\n\n    pub fn term(&self) -> Term {\n        self.current_term.load(Ordering::Acquire)\n    }\n\n    pub fn commit_index(&self) -> LogIndex {\n        let guard = &epoch::pin();\n        let data_ref = self.data.load(Ordering::Acquire, guard);\n        if let Some(data) = unsafe { data_ref.as_ref() } {\n            data.log_state.commit_index\n        } else {\n            0\n        }\n    }\n\n    pub fn log_len(&self) -> u64 {\n        let guard = &epoch::pin();\n        let data_ref = self.data.load(Ordering::Acquire, guard);\n        if let Some(data) = unsafe { data_ref.as_ref() } {\n            data.log_state.entries.len() as u64\n        } else {\n            0\n        }\n    }\n\n    fn quorum_size(cluster_size: usize) -> usize {\n        cluster_size / 2 + 1\n    }\n\n    pub fn tick(&self) {\n        let guard = &epoch::pin();\n        let state = self.state();\n\n        match state {\n            NodeState::Leader => {\n                let elapsed = self.heartbeat_elapsed.fetch_add(1, Ordering::AcqRel) + 1;\n                if elapsed >= self.heartbeat_interval {\n                    self.heartbeat_elapsed.store(0, Ordering::Release);\n                    self.send_heartbeats(guard);\n                }\n            }\n            NodeState::Follower | NodeState::Candidate => {\n                let elapsed = self.election_elapsed.fetch_add(1, Ordering::AcqRel) + 1;\n                if elapsed >= self.election_timeout {\n                    self.start_election(guard);\n                }\n            }\n        }\n    }\n\n    pub fn propose(&self, data: Vec<u8>) -> Result<u64, RaftError> {\n        if self.state() != NodeState::Leader {\n            return Err(RaftError::NotLeader);\n        }\n\n        let guard = &epoch::pin();\n        let term = self.term();\n        \n        loop {\n            let data_ref = self.data.load(Ordering::Acquire, guard);\n            let Some(current_data) = unsafe { data_ref.as_ref() } else {\n                return Err(RaftError::NotLeader);\n            };\n\n            let mut new_data = current_data.clone();\n            let index = new_data.log_state.entries.len() as u64 + 1;\n            let entry = LogEntry {\n                index,\n                term,\n                data: data.clone(),\n            };\n            new_data.log_state.entries.push(entry);\n            new_data.leader_state.match_index.insert(self.id, index);\n\n            let owned = Owned::new(new_data);\n            match self.data.compare_exchange(data_ref, owned, Ordering::AcqRel, Ordering::Acquire, guard) {\n                Ok(_) => {\n                    self.send_append_entries(guard);\n                    return Ok(index);\n                }\n                Err(_) => continue,\n            }\n        }\n    }\n\n    pub fn step(&self, message: Message) -> Result<(), RaftError> {\n        let guard = &epoch::pin();\n        \n        match message {\n            Message::RequestVote { term, candidate_id, last_log_index, last_log_term } => {\n                self.handle_request_vote(guard, term, candidate_id, last_log_index, last_log_term);\n            }\n            Message::RequestVoteResponse { term, voter_id, vote_granted } => {\n                self.handle_vote_response(guard, term, voter_id, vote_granted);\n            }\n            Message::AppendEntries { term, leader_id, prev_log_index, prev_log_term, entries, leader_commit } => {\n                self.handle_append_entries(guard, term, leader_id, prev_log_index, prev_log_term, entries, leader_commit);\n            }\n            Message::AppendEntriesResponse { term, follower_id, success, match_index } => {\n                self.handle_append_entries_response(guard, term, follower_id, success, match_index);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn ready(&self) -> Ready {\n        let guard = &epoch::pin();\n        let data_ref = self.data.load(Ordering::Acquire, guard);\n        \n        if let Some(data) = unsafe { data_ref.as_ref() } {\n            Ready {\n                messages: data.pending_messages.clone(),\n                committed_entries: data.pending_committed.clone(),\n                should_persist: !data.pending_messages.is_empty() || !data.pending_committed.is_empty(),\n            }\n        } else {\n            Ready::default()\n        }\n    }\n\n    pub fn advance(&self, _ready: Ready) {\n        let guard = &epoch::pin();\n        \n        loop {\n            let data_ref = self.data.load(Ordering::Acquire, guard);\n            let Some(current_data) = unsafe { data_ref.as_ref() } else {\n                return;\n            };\n\n            let mut new_data = current_data.clone();\n            new_data.pending_messages.clear();\n            new_data.pending_committed.clear();\n\n            let owned = Owned::new(new_data);\n            match self.data.compare_exchange(data_ref, owned, Ordering::AcqRel, Ordering::Acquire, guard) {\n                Ok(_) => return,\n                Err(_) => continue,\n            }\n        }\n    }\n\n    fn last_log_info(&self, data: &NodeData) -> (LogIndex, Term) {\n        data.log_state.entries.last()\n            .map(|e| (e.index, e.term))\n            .unwrap_or((0, 0))\n    }\n\n    fn start_election(&self, guard: &Guard) {\n        let new_term = self.current_term.fetch_add(1, Ordering::AcqRel) + 1;\n        self.state.store(NodeState::Candidate as u8, Ordering::Release);\n        self.election_elapsed.store(0, Ordering::Release);\n\n        loop {\n            let data_ref = self.data.load(Ordering::Acquire, guard);\n            let Some(current_data) = unsafe { data_ref.as_ref() } else {\n                return;\n            };\n\n            let mut new_data = current_data.clone();\n            new_data.election_state.voted_for = Some(self.id);\n            new_data.election_state.votes_received = vec![self.id];\n            \n            let (last_log_index, last_log_term) = self.last_log_info(&new_data);\n\n            for &peer in &self.peers {\n                new_data.pending_messages.push((\n                    peer,\n                    Message::RequestVote {\n                        term: new_term,\n                        candidate_id: self.id,\n                        last_log_index,\n                        last_log_term,\n                    },\n                ));\n            }\n\n            let owned = Owned::new(new_data);\n            match self.data.compare_exchange(data_ref, owned, Ordering::AcqRel, Ordering::Acquire, guard) {\n                Ok(_) => return,\n                Err(_) => continue,\n            }\n        }\n    }\n\n    fn send_heartbeats(&self, guard: &Guard) {\n        self.send_append_entries(guard);\n    }\n\n    fn send_append_entries(&self, guard: &Guard) {\n        let term = self.term();\n        \n        loop {\n            let data_ref = self.data.load(Ordering::Acquire, guard);\n            let Some(current_data) = unsafe { data_ref.as_ref() } else {\n                return;\n            };\n\n            let mut new_data = current_data.clone();\n\n            for &peer in &self.peers {\n                let next_idx = new_data.leader_state.next_index.get(&peer).copied().unwrap_or(1);\n                let prev_log_index = next_idx.saturating_sub(1);\n                let prev_log_term = if prev_log_index == 0 {\n                    0\n                } else {\n                    new_data.log_state.entries\n                        .get((prev_log_index - 1) as usize)\n                        .map(|e| e.term)\n                        .unwrap_or(0)\n                };\n\n                let entries: Vec<LogEntry> = new_data.log_state.entries\n                    .iter()\n                    .filter(|e| e.index >= next_idx)\n                    .cloned()\n                    .collect();\n\n                new_data.pending_messages.push((\n                    peer,\n                    Message::AppendEntries {\n                        term,\n                        leader_id: self.id,\n                        prev_log_index,\n                        prev_log_term,\n                        entries,\n                        leader_commit: new_data.log_state.commit_index,\n                    },\n                ));\n            }\n\n            let owned = Owned::new(new_data);\n            match self.data.compare_exchange(data_ref, owned, Ordering::AcqRel, Ordering::Acquire, guard) {\n                Ok(_) => return,\n                Err(_) => continue,\n            }\n        }\n    }\n\n    fn handle_request_vote(&self, guard: &Guard, term: Term, candidate_id: NodeId, last_log_index: LogIndex, last_log_term: Term) {\n        let current_term = self.term();\n        \n        if term > current_term {\n            self.current_term.store(term, Ordering::Release);\n            self.state.store(NodeState::Follower as u8, Ordering::Release);\n        }\n\n        loop {\n            let data_ref = self.data.load(Ordering::Acquire, guard);\n            let Some(current_data) = unsafe { data_ref.as_ref() } else {\n                return;\n            };\n\n            let mut new_data = current_data.clone();\n            \n            if term > current_term {\n                new_data.election_state.voted_for = None;\n                new_data.election_state.votes_received.clear();\n            }\n\n            let (my_last_index, my_last_term) = self.last_log_info(&new_data);\n            let log_ok = last_log_term > my_last_term || \n                (last_log_term == my_last_term && last_log_index >= my_last_index);\n\n            let vote_granted = term >= self.term() &&\n                (new_data.election_state.voted_for.is_none() || new_data.election_state.voted_for == Some(candidate_id)) &&\n                log_ok;\n\n            if vote_granted {\n                new_data.election_state.voted_for = Some(candidate_id);\n                self.",
  "score": 50.0,
  "correct": false,
  "generation": 1,
  "parent_id": "26c8bb888b474865",
  "island": 0,
  "level_reached": -1,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: FAIL (24.6s) â€” error: \"error: unknown start of token: `\"\n  output: \"\\n    Blocking waiting for file lock on package cache\\n    Updating crates.io index\\n    Blocking waiting for file lock on package cache\\n     Locking 63 packages to latest compatible versions\\n   Compiling libc v0.2.180\\n    Checking cfg-if v1.0.4\\n   Compiling getrandom v0.3.4\\n    Checking once_cell v1.21.3\\n   Compiling rustversion v1.0.22\\n   Compiling find-msvc-tools v0.1.9\\n    Checking regex-syntax v0.8.9\\n   Compiling rustix v1.1.3\\n   Compiling shlex v1.3.0\\n   Compiling zerocopy v0.8.39\\n   Compiling crossbeam-utils v0.8.21\\n    Checking tracing-core v0.1.36\\n   Compiling cc v1.2.55\\n    Checking log v0.4.29\\n   Compiling autocfg v1.5.0\\n    Checking bitflags v2.10.0\\n    Checking pin-project-lite v0.2.16\\n    Checking lazy_static v1.5.0\\n    Checking fastrand v2.3.0\\n    Checking tracing-log v0.2.0\\n    Checking sharded-slab v0.1.7\\n   Compiling num-traits v0.2.19\\n    Checking tracing v0.1.44\\n    Checking thread_local v1.1.9\\n    Checking fnv v1.0.7\\n    Checking bit-vec v0.8.0\\n    Checking nu-ansi-term v0.50.3\\n    Checking quick-error v1.2.3\\n    Checking smallvec v1.15.1\\n    Checking bit-set v0.8.0\\n    Checking crossbeam-epoch v0.9.18\\n    Checking unarray v0.1.4\\n    Checking scoped-tls v1.0.1\\n    Checking errno v0.3.14\\n    Checking wait-timeout v0.2.1\\n    Checking vf-temp-crate v0.1.0 (/private/var/folders/rc/g8khp7x95kj573cxkyp1swb40000gq/T/vf-cascade-1477146402607965054)\\nerror: unknown start of token: `\\n --> src/lib.rs:1:1\\n  |\\n1 | ```rust\\n  | ^^^\\n  |\\n  = note: character appears 2 more times\\nhelp: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\\n  |\\n1 - ```rust\\n1 + '''rust\\n  |\\n\\nerror: this file contains an unclosed delimiter\\n   --> src/lib.rs:860:2\\n    |\\n123 | impl RaftNode {\\n    |               - unclosed delimiter\\n...\\n409 |     fn handle_request_vote(&self, guard: &Guard, term: Term, candidate_id: NodeId, last_log_index: LogIndex, last_log_term: Term) {\\n    |                                                                                        \"\n",
  "model": "opus"
}